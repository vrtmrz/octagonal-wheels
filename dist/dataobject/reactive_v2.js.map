{"version":3,"file":"reactive_v2.js","sources":["../../src/dataobject/reactive_v2.ts"],"sourcesContent":["// Reactive and less-computing expression evaluator\n// Inspired from Vue\n\nimport { FallbackWeakRef } from \"../common/polyfill\";\nimport { isObjectDifferent } from \"../object\";\n\nlet context: InternalReactiveInstance<any> | undefined;\nexport type ReactiveChangeHandler<T> = (instance: ReactiveInstance<T>) => unknown;\n\nexport type ReactiveExpression<T> = (prev?: T) => T;\n\nexport type ReactiveValue<T> = {\n    readonly value: T;\n    onChanged: (handler: ReactiveChangeHandler<T>) => void;\n    offChanged: (handler: ReactiveChangeHandler<T>) => void;\n};\nexport type ReactiveSource<T> = {\n    value: T;\n    onChanged: (handler: ReactiveChangeHandler<T>) => void;\n    offChanged: (handler: ReactiveChangeHandler<T>) => void;\n\n};\n\nexport type ReactiveInstance<T> = {\n    readonly value: T;\n    markDirty(): void;\n    markClean(): void;\n    rippleChanged(): void;\n};\ntype InternalReactiveInstance<T> = ReactiveInstance<T> & {\n    readonly isDirty: boolean;\n    readonly id: number;\n    dependants: Set<InternalReactiveInstance<unknown>>;\n    _markDirty(): void;\n    _rippleChanged(): void;\n    onChanged(handler: ReactiveChangeHandler<T>): void;\n    offChanged(handler: ReactiveChangeHandler<T>): void;\n};\n\n/**\n * Creates a reactive instance with the given initial value.\n *\n * @template T - The type of the reactive instance.\n * @param initialValue - The initial value of the reactive instance.\n * @returns A reactive instance with the given initial value.\n */\nexport function reactiveSource<T>(initialValue: T): ReactiveSource<T> {\n    return _reactive({ initialValue });\n}\n/**\n * Creates a reactive value that tracks changes to a given expression.\n *\n * @template T - The type of the reactive value.\n * @param {function(prev?: T): T} expression - The expression to track changes for.\n * @param {T} [initialValue] - The initial value of the reactive value.\n * @returns {ReactiveValue<T>} - The reactive value.\n */\nexport function reactive<T>(expression: (prev?: T) => T, initialValue?: T): ReactiveValue<T> {\n    return _reactive({ expression, initialValue });\n}\ntype reactiveParams<T> = {\n    expression: (prev?: T) => T,\n    initialValue?: T;\n    isSource?: boolean;\n} | {\n    expression?: (prev?: T) => T,\n    initialValue: T;\n    isSource?: boolean;\n};\n\ntype RefReactiveInstance<T> = {\n    id: number;\n    instance: FallbackWeakRef<InternalReactiveInstance<T>>;\n};\nconst topologicalSortCache = new Map<number, RefReactiveInstance<unknown>[]>();\n\n// function resetTopologicalSortCache() {\n//     topologicalSortCache.clear();\n// }\n\nfunction resetTopologicalSortCacheFor(ids: number[]) {\n    ids.forEach(id => topologicalSortCache.delete(id));\n    topologicalSortCache.forEach((value, key) => {\n        if (!ids.includes(key)) {\n            topologicalSortCache.delete(key);\n        }\n    });\n}\nfunction topologicalSort(startNode: InternalReactiveInstance<unknown>): InternalReactiveInstance<unknown>[] {\n    if (topologicalSortCache.has(startNode.id)) {\n        const ref = topologicalSortCache.get(startNode.id);\n        if (ref) {\n            const result = ref.map(e => e.instance.deref()).filter(e => e) as InternalReactiveInstance<unknown>[];\n            if (result.length === ref.length) {\n                return result;\n            }\n            // if not matched, some of the references are already garbage collected, we need to recompute the topological sort\n        }\n    }\n    const visited = new Set<InternalReactiveInstance<unknown>>();\n    const sorted: InternalReactiveInstance<unknown>[] = [];\n    const recursionStack = new Set<ReactiveInstance<unknown>>(); // for cycle detection\n\n    function visit(node: InternalReactiveInstance<unknown>) {\n        if (visited.has(node)) {\n            return;\n        }\n        if (recursionStack.has(node)) {\n            // Circular dependency detected, throw an error, we can't resolve this\n            throw new Error(\"Circular dependency detected!\");\n        }\n        visited.add(node);\n        recursionStack.add(node);\n        for (const dependant of node.dependants) {\n            visit(dependant);\n        }\n        sorted.push(node);\n        recursionStack.delete(node);\n    }\n\n    visit(startNode);\n    const result = sorted.reverse();\n    topologicalSortCache.set(startNode.id, result.map(e => ({ id: e.id, instance: new FallbackWeakRef(e) })));\n    return result; // The order of the sorted array is the order of the dependency\n}\n\nlet _reactiveSourceId = 0;\nfunction _reactive<T>({ expression, initialValue, isSource }: reactiveParams<T>): ReactiveValue<T> {\n    let value: T;\n    let _isDirty = false;\n    const id = _reactiveSourceId++;\n    const changeHandlers = new Set<((value: ReactiveInstance<T>) => unknown)>;\n\n    const instance: InternalReactiveInstance<T> = {\n        id,\n        dependants: new Set<InternalReactiveInstance<unknown>>(),\n        _markDirty() {\n            if (_isDirty) return;\n            _isDirty = true;\n        },\n        markDirty() {\n            const sorted = topologicalSort(instance);\n            sorted.forEach(node => node._markDirty());\n        },\n        _rippleChanged() {\n            changeHandlers.forEach(e => e(instance));\n        },\n        rippleChanged() {\n            const sorted = topologicalSort(instance);\n            sorted.forEach(node => node._rippleChanged());\n        },\n        markClean() {\n            _isDirty = false;\n        },\n        get isDirty() {\n            return _isDirty;\n        },\n        get value(): T {\n            if (context) {\n                if (!instance.dependants.has(context as InternalReactiveInstance<unknown>)) {\n                    instance.dependants.add(context as InternalReactiveInstance<unknown>);\n                    resetTopologicalSortCacheFor([instance.id, (context).id]);\n                }\n            }\n            if (_isDirty) {\n                // if it has been marked dirty, we need to re-evaluate the expression (if supplied)\n                // If not (means it is a source), indeed we do not need to re-evaluate the expression. But should un-flag it.\n                if (expression) {\n                    const oldValue = value;\n                    const newValue = expression();\n                    if (isObjectDifferent(oldValue, newValue)) {\n                        value = newValue;\n                    }\n                }\n                // After re-evaluating the expression, we mark it clean\n                instance.markClean();\n            }\n            return value;\n        },\n        set value(newValue: T) {\n            // If already dirty and it is a source, we do not need to re-evaluate the expression\n            // (If it is a source, the source should be unflagged after the value has bee retrieved,\n            //  so we do not need to check the difference and raise the change event)\n            if (_isDirty && !expression) {\n                value = newValue;\n            } else if (isObjectDifferent(value, newValue)) {\n                value = newValue;\n                if (!_isDirty) {\n                    instance.markDirty();\n                    instance.rippleChanged();\n                }\n            }\n        },\n        onChanged(handler: ReactiveChangeHandler<T>) {\n            changeHandlers.add(handler);\n        },\n        offChanged(handler: ReactiveChangeHandler<T>) {\n            changeHandlers.delete(handler);\n        }\n    };\n\n    value = initialize();\n\n    function initialize(): T {\n        // Set self to the global variable for tracking the dependency while evaluating the expression\n        const previousContext = context;\n        context = instance;\n        const r = expression ? expression(initialValue) : initialValue;\n        context = previousContext;\n        return r as T;\n    }\n\n    return instance as ReactiveValue<T>;\n}\n\n/**\n * Creates a computed value based on a reactive expression.\n * @param expression The reactive expression to compute.\n * @returns A function that returns the computed value.\n */\nexport function computed<T>(expression: ReactiveExpression<T>): () => T {\n    const v = reactive(expression);\n    return () => v.value;\n}"],"names":[],"mappings":"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"}