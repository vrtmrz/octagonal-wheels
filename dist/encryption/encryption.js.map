{"version":3,"file":"encryption.js","sources":["../../src/encryption/encryption.ts"],"sourcesContent":["import { decodeBinary } from \"../binary\";\nimport { arrayBufferToBase64Single, readString, writeString } from \"../binary/base64\";\nimport { hexStringToUint8Array, uint8ArrayToHexString } from \"../binary/hex\";\nimport { LOG_LEVEL_VERBOSE, Logger } from \"../common/logger\";\nimport { decryptV3, encryptV3 } from \"./encryptionv3\";\n\nexport type encodedData = [encryptedData: string, iv: string, salt: string];\nexport type KeyBuffer = {\n    key: CryptoKey;\n    salt: Uint8Array;\n    count: number;\n};\n\nconst KeyBuffs = new Map<string, KeyBuffer>();\nconst decKeyBuffs = new Map<string, KeyBuffer>();\n\nconst KEY_RECYCLE_COUNT = 100;\n\nlet semiStaticFieldBuffer: Uint8Array;\nconst nonceBuffer: Uint32Array = new Uint32Array(1);\n\nconst webcrypto = globalThis.crypto;\n\n/**\n * Retrieves the encryption key and salt for encrypting data using the provided passphrase.\n * @param passphrase - The passphrase used to derive the encryption key.\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the number of iterations based on the passphrase length.\n * @returns A Promise that resolves to an array containing the encryption key and salt.\n */\nasync function getKeyForEncrypt(passphrase: string, autoCalculateIterations: boolean): Promise<[CryptoKey, Uint8Array]> {\n    // For performance, the plugin reuses the key KEY_RECYCLE_COUNT times.\n    const buffKey = `${passphrase}-${autoCalculateIterations}`;\n    const f = KeyBuffs.get(buffKey);\n    if (f) {\n        f.count--;\n        if (f.count > 0) {\n            return [f.key, f.salt];\n        }\n        f.count--;\n    }\n    const passphraseLen = 15 - passphrase.length;\n    const iteration = autoCalculateIterations ? ((passphraseLen > 0 ? passphraseLen : 0) * 1000) + 121 - passphraseLen : 100000;\n    const passphraseBin = new TextEncoder().encode(passphrase);\n    const digest = await webcrypto.subtle.digest({ name: \"SHA-256\" }, passphraseBin);\n    const keyMaterial = await webcrypto.subtle.importKey(\"raw\", digest, { name: \"PBKDF2\" }, false, [\"deriveKey\"]);\n    const salt = webcrypto.getRandomValues(new Uint8Array(16));\n    const key = await webcrypto.subtle.deriveKey(\n        {\n            name: \"PBKDF2\",\n            salt,\n            iterations: iteration,\n            hash: \"SHA-256\",\n        },\n        keyMaterial,\n        { name: \"AES-GCM\", length: 256 },\n        false,\n        [\"encrypt\"]\n    );\n    KeyBuffs.set(buffKey, {\n        key,\n        salt,\n        count: KEY_RECYCLE_COUNT,\n    });\n    return [key, salt];\n}\nlet keyGCCount = KEY_RECYCLE_COUNT * 5;\nlet decKeyIdx = 0;\nlet decKeyMin = 0;\n/**\n * Retrieves the encryption key for decryption.\n * \n * @param passphrase - The passphrase used for encryption.\n * @param salt - The salt value used for encryption.\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the iteration count.\n * @returns A promise that resolves to a tuple containing the encryption key and the salt value.\n */\nasync function getKeyForDecryption(passphrase: string, salt: Uint8Array, autoCalculateIterations: boolean): Promise<[CryptoKey, Uint8Array]> {\n\n    keyGCCount--;\n    if (keyGCCount < 0) {\n        keyGCCount = KEY_RECYCLE_COUNT;\n        // drop 50% of cache.\n        const threshold = (decKeyIdx - decKeyMin) / 2;\n        for (const [key, buff] of decKeyBuffs) {\n            if (buff.count < threshold) {\n                decKeyBuffs.delete(key);\n            }\n            decKeyMin = decKeyIdx;\n        }\n    }\n    decKeyIdx++;\n    const bufKey = passphrase + uint8ArrayToHexString(salt) + autoCalculateIterations;\n    const f = decKeyBuffs.get(bufKey);\n    if (f) {\n        f.count = decKeyIdx;\n        return [f.key, f.salt];\n    }\n    const passphraseLen = 15 - passphrase.length;\n    const iteration = autoCalculateIterations ? ((passphraseLen > 0 ? passphraseLen : 0) * 1000) + 121 - passphraseLen : 100000;\n\n    const passphraseBin = new TextEncoder().encode(passphrase);\n    const digest = await webcrypto.subtle.digest({ name: \"SHA-256\" }, passphraseBin);\n    const keyMaterial = await webcrypto.subtle.importKey(\"raw\", digest, { name: \"PBKDF2\" }, false, [\"deriveKey\"]);\n    const key = await webcrypto.subtle.deriveKey(\n        {\n            name: \"PBKDF2\",\n            salt,\n            iterations: iteration,\n            hash: \"SHA-256\",\n        },\n        keyMaterial,\n        { name: \"AES-GCM\", length: 256 },\n        false,\n        [\"decrypt\"]\n    );\n    decKeyBuffs.set(bufKey, {\n        key,\n        salt,\n        count: 0,\n    });\n    return [key, salt];\n}\n\n/**\n * Retrieves the semi-static field used for encryption.\n * \n * @param reset - Optional parameter to reset the field.\n * @returns The semi-static field.\n */\nfunction getSemiStaticField(reset?: boolean) {\n    // return fixed field of iv.\n    if (semiStaticFieldBuffer != null && !reset) {\n        return semiStaticFieldBuffer;\n    }\n    semiStaticFieldBuffer = webcrypto.getRandomValues(new Uint8Array(12));\n    return semiStaticFieldBuffer;\n}\n\n/**\n * Generates a nonce for encryption.\n * \n * @returns The generated nonce.\n */\nfunction getNonce() {\n    // This is nonce, so do not send same thing.\n    nonceBuffer[0]++;\n    if (nonceBuffer[0] > 10000) {\n        // reset semi-static field.\n        getSemiStaticField(true);\n    }\n    return nonceBuffer;\n}\n\n/**\n * Encrypts the input string using AES-GCM encryption algorithm.\n * @param input - The string to be encrypted.\n * @param passphrase - The passphrase used for encryption.\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the iterations for key derivation.\n * @returns A string representing the encrypted data, initialization vector (IV), and salt in JSON format.\n */\nexport async function encryptV1(input: string, passphrase: string, autoCalculateIterations: boolean) {\n    const [key, salt] = await getKeyForEncrypt(passphrase, autoCalculateIterations);\n    // Create initial vector with semi-fixed part and incremental part\n    // I think it's not good against related-key attacks.\n    const fixedPart = getSemiStaticField();\n    const invocationPart = getNonce();\n    const iv = new Uint8Array([...fixedPart, ...new Uint8Array(invocationPart.buffer)]);\n    const plainStringified = JSON.stringify(input);\n    const plainStringBuffer: Uint8Array = writeString(plainStringified);\n    const encryptedDataArrayBuffer = await webcrypto.subtle.encrypt({ name: \"AES-GCM\", iv }, key, plainStringBuffer);\n    const encryptedData2 = (await arrayBufferToBase64Single(encryptedDataArrayBuffer));\n    const ret = `[\"${encryptedData2}\",\"${uint8ArrayToHexString(iv)}\",\"${uint8ArrayToHexString(salt)}\"]`;\n    return ret;\n}\n\n/**\n * Encrypts the input string using AES-GCM encryption algorithm.\n * \n * @param input - The string to be encrypted.\n * @param passphrase - The passphrase used for encryption.\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the iterations for key derivation.\n * @returns The encrypted data with initialization vector (iv) and salt. <br>  |%| iv(32) | salt(32) | data ....  \n */\nexport async function encrypt(input: string, passphrase: string, autoCalculateIterations: boolean) {\n    const [key, salt] = await getKeyForEncrypt(passphrase, autoCalculateIterations);\n    // Create initial vector with semi-fixed part and incremental part\n    // I think it's not good against related-key attacks.\n    const fixedPart = getSemiStaticField();\n    const invocationPart = getNonce();\n    const iv = new Uint8Array([...fixedPart, ...new Uint8Array(invocationPart.buffer)]);\n    const dataBuf = writeString(input)\n    const encryptedDataArrayBuffer = await webcrypto.subtle.encrypt({ name: \"AES-GCM\", iv }, key, dataBuf);\n    const encryptedData2 = \"\" + await arrayBufferToBase64Single(new Uint8Array(encryptedDataArrayBuffer));\n    // return data with iv and salt.\n    // |%| iv(32) | salt(32) | data ....  \n    const ret = `%${uint8ArrayToHexString(iv)}${uint8ArrayToHexString(salt)}${encryptedData2}`;\n    return ret;\n}\n/**\n * Generates a key, salt, and IV for obfuscating a path using the provided passphrase.\n * @param passphrase - The passphrase used for key generation.\n * @param dataBuf - The data buffer to be used in key derivation.\n * @param autoCalculateIterations - A flag indicating whether to automatically calculate the number of iterations based on the passphrase length.\n * @returns A promise that resolves to an array containing the generated key, salt, and IV.\n */\nasync function getKeyForObfuscatePath(passphrase: string, dataBuf: Uint8Array, autoCalculateIterations: boolean): Promise<[CryptoKey, Uint8Array, Uint8Array]> {\n    const passphraseLen = 15 - passphrase.length;\n    const iteration = autoCalculateIterations ? ((passphraseLen > 0 ? passphraseLen : 0) * 1000) + 121 - passphraseLen : 100000;\n    const passphraseBin = new TextEncoder().encode(passphrase);\n    const digest = await webcrypto.subtle.digest({ name: \"SHA-256\" }, passphraseBin);\n    const buf2 = new Uint8Array(await webcrypto.subtle.digest({ name: \"SHA-256\" }, new Uint8Array([...dataBuf, ...passphraseBin])));\n    const salt = buf2.slice(0, 16);\n    const iv = buf2.slice(16, 32);\n    const keyMaterial = await webcrypto.subtle.importKey(\"raw\", digest, { name: \"PBKDF2\" }, false, [\"deriveKey\"]);\n    const key = await webcrypto.subtle.deriveKey(\n        {\n            name: \"PBKDF2\",\n            salt,\n            iterations: iteration,\n            hash: \"SHA-256\",\n        },\n        keyMaterial,\n        { name: \"AES-GCM\", length: 256 },\n        false,\n        [\"encrypt\"]\n    );\n    return [key, salt, iv];\n}\n/**\n * Obfuscates the given path using AES-GCM encryption. This obfuscation is deterministic.\n * @param path - The path to obfuscate.\n * @param passphrase - The passphrase used for encryption.\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the iterations.\n * @returns The obfuscated path: |%| iv(32) | salt(32) | data ....  \n */\nexport async function obfuscatePath<T extends string>(path: T, passphrase: string, autoCalculateIterations: boolean) {\n    const dataBuf = writeString(path)\n    const [key, salt, iv] = await getKeyForObfuscatePath(passphrase, dataBuf, autoCalculateIterations);\n    const encryptedDataArrayBuffer = await webcrypto.subtle.encrypt(\n        {\n            name: \"AES-GCM\",\n            iv: iv,\n        },\n        key,\n        dataBuf,\n    );\n    const encryptedData2 = await arrayBufferToBase64Single(new Uint8Array(encryptedDataArrayBuffer));\n    // return data with iv and salt.\n    // |%| iv(32) | salt(32) | data ....  \n    const ret = `%${uint8ArrayToHexString(iv)}${uint8ArrayToHexString(salt)}${encryptedData2}`;\n    return ret;\n}\n\n\n/**\n * Checks if a given path is probably obfuscated.\n * \n * @param path - The path to check.\n * @returns `true` if the path is probably obfuscated, `false` otherwise.\n */\nexport function isPathProbablyObfuscated(path: string) {\n    return path.startsWith(\"%\") && path.length > 64;\n}\n\n/**\n * Decrypts the encrypted result using the provided passphrase and returns the decrypted string.\n * @param encryptedResult - The encrypted result to decrypt.\n * @param passphrase - The passphrase used for decryption.\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the iterations for key derivation.\n * @returns A Promise that resolves to the decrypted string.\n * @throws If decryption fails or an error occurs during the decryption process.\n */\nasync function decryptV2(encryptedResult: string, passphrase: string, autoCalculateIterations: boolean): Promise<string> {\n    try {\n        const ivStr = encryptedResult.substring(1, 33);\n        const salt = encryptedResult.substring(33, 65);\n        const encryptedData = encryptedResult.substring(65);\n        const [key] = await getKeyForDecryption(passphrase, hexStringToUint8Array(salt), autoCalculateIterations);\n        const iv = hexStringToUint8Array(ivStr);\n        const encryptedDataArrayBuffer = decodeBinary(encryptedData)\n        const dataBuffer = await webcrypto.subtle.decrypt({ name: \"AES-GCM\", iv }, key, encryptedDataArrayBuffer);\n        const plain = readString(new Uint8Array(dataBuffer));\n        return plain;\n    } catch (ex) {\n        Logger(\"Couldn't decode! You should wrong the passphrases (V2)\", LOG_LEVEL_VERBOSE);\n        Logger(ex, LOG_LEVEL_VERBOSE);\n        throw ex;\n    }\n}\n\n/**\n * Decrypts the encrypted result using the provided passphrase.\n * @param encryptedResult - The encrypted result to decrypt.\n * @param passphrase - The passphrase used for decryption.\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the iterations.\n * @returns A Promise that resolves to the decrypted string.\n * @throws If the encrypted data is corrupted or if decryption fails.\n */\nexport async function decrypt(encryptedResult: string, passphrase: string, autoCalculateIterations: boolean): Promise<string> {\n    try {\n        if (encryptedResult[0] == \"%\") {\n            if (encryptedResult[1] === \"~\") {\n                return decryptV3(encryptedResult, passphrase);\n            }\n            return decryptV2(encryptedResult, passphrase, autoCalculateIterations);\n        }\n        if (!encryptedResult.startsWith(\"[\") || !encryptedResult.endsWith(\"]\")) {\n            throw new Error(\"Encrypted data corrupted!\");\n        }\n        const w: any = encryptedResult.substring(1, encryptedResult.length - 1).split(\",\").map(e => e[0] == '\"' ? e.substring(1, e.length - 1) : e);\n        const [encryptedData, ivString, salt]: encodedData = w;\n        const [key] = await getKeyForDecryption(passphrase, hexStringToUint8Array(salt), autoCalculateIterations);\n        const iv = hexStringToUint8Array(ivString);\n        // decode base 64, it should increase speed and i should with in MAX_DOC_SIZE_BIN, so it won't OOM.\n        const encryptedDataBin = atob(encryptedData);\n        const len = encryptedDataBin.length;\n        const encryptedDataArrayBuffer = new Uint8Array(len);\n        // converting binary string to arraybuffer\n        for (let i = len; i >= 0; --i) {\n            encryptedDataArrayBuffer[i] = encryptedDataBin.charCodeAt(i);\n        }\n        const plainStringBuffer: ArrayBuffer = await webcrypto.subtle.decrypt({ name: \"AES-GCM\", iv }, key, encryptedDataArrayBuffer);\n        const plainStringified = readString(new Uint8Array(plainStringBuffer));\n        const plain = JSON.parse(plainStringified);\n        return plain;\n    } catch (ex) {\n        Logger(\"Couldn't decode! You should wrong the passphrases\", LOG_LEVEL_VERBOSE);\n        Logger(ex, LOG_LEVEL_VERBOSE);\n        throw ex;\n    }\n}\n\n/**\n * Tries to decrypt the encrypted result using the provided passphrase.\n * \n * @param encryptedResult - The encrypted result to decrypt.\n * @param passphrase - The passphrase used for decryption.\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the iterations.\n * @returns A promise that resolves to the decrypted result if successful, or `false` if decryption fails.\n */\nexport async function tryDecrypt(encryptedResult: string, passphrase: string | false, autoCalculateIterations: boolean): Promise<string | false> {\n    if (!passphrase) return false;\n    try {\n        return await decrypt(encryptedResult, passphrase, autoCalculateIterations);\n    } catch (ex) {\n        return false;\n    }\n}\n\nexport async function testCryptV3() {\n    const src = \"✨supercalifragilisticexpialidocious✨⛰️\";\n    const encoded = await encryptV3(src, \"passwordTest\");\n    const decrypted = await decrypt(encoded, \"passwordTest\", false);\n    if (src != decrypted) {\n        Logger(\"WARNING! Your device would not support encryption V3.\", LOG_LEVEL_VERBOSE);\n        return false;\n    } else {\n        Logger(\"CRYPT LOGIC (V3) OK\", LOG_LEVEL_VERBOSE);\n        return true;\n    }\n}\n\n/**\n * Tests the encryption and decryption functionality.\n * @returns {Promise<boolean>} A promise that resolves to `true` if encryption and decryption are successful, and `false` otherwise.\n */\nexport async function testCrypt() {\n    const src = \"✨supercalifragilisticexpialidocious✨⛰️\";\n\n    const encoded = await encrypt(src, \"passwordTest\", false);\n    const decrypted = await decrypt(encoded, \"passwordTest\", false);\n    if (src != decrypted) {\n        Logger(\"WARNING! Your device would not support encryption.\", LOG_LEVEL_VERBOSE);\n        return false;\n    } else {\n        Logger(\"CRYPT LOGIC OK\", LOG_LEVEL_VERBOSE);\n        const w = new TextEncoder().encode(src);\n        const encodedBinary = await encryptBinary(w, \"passwordTest\", false);\n        const decryptedBinary = await decryptBinary(encodedBinary, \"passwordTest\", false);\n\n        if (w.join(\"-\") !== decryptedBinary.join(\"-\")) {\n            Logger(\"WARNING! Your device would not support encryption (Binary).\", LOG_LEVEL_VERBOSE);\n            return false;\n        } else {\n            Logger(\"CRYPT LOGIC OK (Binary)\", LOG_LEVEL_VERBOSE);\n        }\n        return await testCryptV3();\n    }\n}\n\n/**\n * Encrypts binary data using AES-GCM encryption algorithm.\n * \n * @param input - The binary data to be encrypted.\n * @param passphrase - The passphrase used to derive the encryption key.\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the number of iterations for key derivation.\n * @returns The encrypted binary data.\n */\nexport async function encryptBinary(input: Uint8Array, passphrase: string, autoCalculateIterations: boolean) {\n    const [key, salt] = await getKeyForEncrypt(passphrase, autoCalculateIterations);\n    // Create initial vector with semi-fixed part and incremental part\n    // I think it's not good against related-key attacks.\n    const fixedPart = getSemiStaticField();\n    const invocationPart = getNonce();\n    const iv = new Uint8Array([...fixedPart, ...new Uint8Array(invocationPart.buffer)]);\n    const dataBuf = input\n    const encryptedDataArrayBuffer = new Uint8Array(await webcrypto.subtle.encrypt({ name: \"AES-GCM\", iv }, key, dataBuf));\n    const ret = new Uint8Array(encryptedDataArrayBuffer.byteLength + iv.byteLength + salt.byteLength);\n    ret.set(iv, 0);\n    ret.set(salt, iv.byteLength);\n    ret.set(encryptedDataArrayBuffer, iv.byteLength + salt.byteLength);\n    return ret;\n}\n/**\n * Decrypts the encrypted binary data using the provided passphrase.\n * @param encryptedResult - The encrypted binary data as a Uint8Array.\n * @param passphrase - The passphrase used for decryption.\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the iterations for key derivation.\n * @returns A Promise that resolves to the decrypted binary data as a Uint8Array.\n * @throws If decryption fails or an error occurs during the decryption process.\n */\nexport async function decryptBinary(encryptedResult: Uint8Array, passphrase: string, autoCalculateIterations: boolean): Promise<Uint8Array> {\n    try {\n        const iv = encryptedResult.slice(0, 16);\n        const salt = encryptedResult.slice(16, 32);\n        const encryptedData = encryptedResult.slice(32);\n        const [key] = await getKeyForDecryption(passphrase, salt, autoCalculateIterations);\n        const dataBuffer = await webcrypto.subtle.decrypt({ name: \"AES-GCM\", iv }, key, encryptedData);\n        return new Uint8Array(dataBuffer)\n    } catch (ex) {\n        Logger(\"Couldn't decode! You should wrong the passphrases (V2 Bin)\", LOG_LEVEL_VERBOSE);\n        Logger(ex, LOG_LEVEL_VERBOSE);\n        throw ex;\n    }\n}\n\n"],"names":[],"mappings":"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"}