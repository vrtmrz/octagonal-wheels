{"version":3,"file":"encryption.js","sources":["../../src/encryption/encryption.ts"],"sourcesContent":["import { decodeBinary } from \"../binary\";\r\nimport { arrayBufferToBase64Single, readString, writeString } from \"../binary/base64\";\r\nimport { hexStringToUint8Array, uint8ArrayToHexString } from \"../binary/hex\";\r\nimport { LOG_LEVEL_VERBOSE, Logger } from \"../common/logger\";\r\nimport { decryptV3, encryptV3 } from \"./encryptionv3\";\r\n\r\nexport type encodedData = [encryptedData: string, iv: string, salt: string];\r\nexport type KeyBuffer = {\r\n    key: CryptoKey;\r\n    salt: Uint8Array;\r\n    count: number;\r\n};\r\n\r\nconst KeyBuffs = new Map<string, KeyBuffer>();\r\nconst decKeyBuffs = new Map<string, KeyBuffer>();\r\n\r\nconst KEY_RECYCLE_COUNT = 100;\r\n\r\nlet semiStaticFieldBuffer: Uint8Array;\r\nconst nonceBuffer: Uint32Array = new Uint32Array(1);\r\n\r\nconst webcrypto = globalThis.crypto;\r\n\r\n/**\r\n * Retrieves the encryption key and salt for encrypting data using the provided passphrase.\r\n * @param passphrase - The passphrase used to derive the encryption key.\r\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the number of iterations based on the passphrase length.\r\n * @returns A Promise that resolves to an array containing the encryption key and salt.\r\n */\r\nasync function getKeyForEncrypt(passphrase: string, autoCalculateIterations: boolean): Promise<[CryptoKey, Uint8Array]> {\r\n    // For performance, the plugin reuses the key KEY_RECYCLE_COUNT times.\r\n    const buffKey = `${passphrase}-${autoCalculateIterations}`;\r\n    const f = KeyBuffs.get(buffKey);\r\n    if (f) {\r\n        f.count--;\r\n        if (f.count > 0) {\r\n            return [f.key, f.salt];\r\n        }\r\n        f.count--;\r\n    }\r\n    const passphraseLen = 15 - passphrase.length;\r\n    const iteration = autoCalculateIterations ? ((passphraseLen > 0 ? passphraseLen : 0) * 1000) + 121 - passphraseLen : 100000;\r\n    const passphraseBin = new TextEncoder().encode(passphrase);\r\n    const digest = await webcrypto.subtle.digest({ name: \"SHA-256\" }, passphraseBin);\r\n    const keyMaterial = await webcrypto.subtle.importKey(\"raw\", digest, { name: \"PBKDF2\" }, false, [\"deriveKey\"]);\r\n    const salt = webcrypto.getRandomValues(new Uint8Array(16));\r\n    const key = await webcrypto.subtle.deriveKey(\r\n        {\r\n            name: \"PBKDF2\",\r\n            salt,\r\n            iterations: iteration,\r\n            hash: \"SHA-256\",\r\n        },\r\n        keyMaterial,\r\n        { name: \"AES-GCM\", length: 256 },\r\n        false,\r\n        [\"encrypt\"]\r\n    );\r\n    KeyBuffs.set(buffKey, {\r\n        key,\r\n        salt,\r\n        count: KEY_RECYCLE_COUNT,\r\n    });\r\n    return [key, salt];\r\n}\r\nlet keyGCCount = KEY_RECYCLE_COUNT * 5;\r\nlet decKeyIdx = 0;\r\nlet decKeyMin = 0;\r\n/**\r\n * Retrieves the encryption key for decryption.\r\n * \r\n * @param passphrase - The passphrase used for encryption.\r\n * @param salt - The salt value used for encryption.\r\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the iteration count.\r\n * @returns A promise that resolves to a tuple containing the encryption key and the salt value.\r\n */\r\nasync function getKeyForDecryption(passphrase: string, salt: Uint8Array, autoCalculateIterations: boolean): Promise<[CryptoKey, Uint8Array]> {\r\n\r\n    keyGCCount--;\r\n    if (keyGCCount < 0) {\r\n        keyGCCount = KEY_RECYCLE_COUNT;\r\n        // drop 50% of cache.\r\n        const threshold = (decKeyIdx - decKeyMin) / 2;\r\n        for (const [key, buff] of decKeyBuffs) {\r\n            if (buff.count < threshold) {\r\n                decKeyBuffs.delete(key);\r\n            }\r\n            decKeyMin = decKeyIdx;\r\n        }\r\n    }\r\n    decKeyIdx++;\r\n    const bufKey = passphrase + uint8ArrayToHexString(salt) + autoCalculateIterations;\r\n    const f = decKeyBuffs.get(bufKey);\r\n    if (f) {\r\n        f.count = decKeyIdx;\r\n        return [f.key, f.salt];\r\n    }\r\n    const passphraseLen = 15 - passphrase.length;\r\n    const iteration = autoCalculateIterations ? ((passphraseLen > 0 ? passphraseLen : 0) * 1000) + 121 - passphraseLen : 100000;\r\n\r\n    const passphraseBin = new TextEncoder().encode(passphrase);\r\n    const digest = await webcrypto.subtle.digest({ name: \"SHA-256\" }, passphraseBin);\r\n    const keyMaterial = await webcrypto.subtle.importKey(\"raw\", digest, { name: \"PBKDF2\" }, false, [\"deriveKey\"]);\r\n    const key = await webcrypto.subtle.deriveKey(\r\n        {\r\n            name: \"PBKDF2\",\r\n            salt,\r\n            iterations: iteration,\r\n            hash: \"SHA-256\",\r\n        },\r\n        keyMaterial,\r\n        { name: \"AES-GCM\", length: 256 },\r\n        false,\r\n        [\"decrypt\"]\r\n    );\r\n    decKeyBuffs.set(bufKey, {\r\n        key,\r\n        salt,\r\n        count: 0,\r\n    });\r\n    return [key, salt];\r\n}\r\n\r\n/**\r\n * Retrieves the semi-static field used for encryption.\r\n * \r\n * @param reset - Optional parameter to reset the field.\r\n * @returns The semi-static field.\r\n */\r\nfunction getSemiStaticField(reset?: boolean) {\r\n    // return fixed field of iv.\r\n    if (semiStaticFieldBuffer != null && !reset) {\r\n        return semiStaticFieldBuffer;\r\n    }\r\n    semiStaticFieldBuffer = webcrypto.getRandomValues(new Uint8Array(12));\r\n    return semiStaticFieldBuffer;\r\n}\r\n\r\n/**\r\n * Generates a nonce for encryption.\r\n * \r\n * @returns The generated nonce.\r\n */\r\nfunction getNonce() {\r\n    // This is nonce, so do not send same thing.\r\n    nonceBuffer[0]++;\r\n    if (nonceBuffer[0] > 10000) {\r\n        // reset semi-static field.\r\n        getSemiStaticField(true);\r\n    }\r\n    return nonceBuffer;\r\n}\r\n\r\n/**\r\n * Encrypts the input string using AES-GCM encryption algorithm.\r\n * @param input - The string to be encrypted.\r\n * @param passphrase - The passphrase used for encryption.\r\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the iterations for key derivation.\r\n * @returns A string representing the encrypted data, initialization vector (IV), and salt in JSON format.\r\n */\r\nexport async function encryptV1(input: string, passphrase: string, autoCalculateIterations: boolean) {\r\n    const [key, salt] = await getKeyForEncrypt(passphrase, autoCalculateIterations);\r\n    // Create initial vector with semi-fixed part and incremental part\r\n    // I think it's not good against related-key attacks.\r\n    const fixedPart = getSemiStaticField();\r\n    const invocationPart = getNonce();\r\n    const iv = new Uint8Array([...fixedPart, ...new Uint8Array(invocationPart.buffer)]);\r\n    const plainStringified = JSON.stringify(input);\r\n    const plainStringBuffer: Uint8Array = writeString(plainStringified);\r\n    const encryptedDataArrayBuffer = await webcrypto.subtle.encrypt({ name: \"AES-GCM\", iv }, key, plainStringBuffer);\r\n    const encryptedData2 = (await arrayBufferToBase64Single(encryptedDataArrayBuffer));\r\n    const ret = `[\"${encryptedData2}\",\"${uint8ArrayToHexString(iv)}\",\"${uint8ArrayToHexString(salt)}\"]`;\r\n    return ret;\r\n}\r\n\r\n/**\r\n * Encrypts the input string using AES-GCM encryption algorithm.\r\n * \r\n * @param input - The string to be encrypted.\r\n * @param passphrase - The passphrase used for encryption.\r\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the iterations for key derivation.\r\n * @returns The encrypted data with initialization vector (iv) and salt. <br>  |%| iv(32) | salt(32) | data ....  \r\n */\r\nexport async function encrypt(input: string, passphrase: string, autoCalculateIterations: boolean) {\r\n    const [key, salt] = await getKeyForEncrypt(passphrase, autoCalculateIterations);\r\n    // Create initial vector with semi-fixed part and incremental part\r\n    // I think it's not good against related-key attacks.\r\n    const fixedPart = getSemiStaticField();\r\n    const invocationPart = getNonce();\r\n    const iv = new Uint8Array([...fixedPart, ...new Uint8Array(invocationPart.buffer)]);\r\n    const dataBuf = writeString(input)\r\n    const encryptedDataArrayBuffer = await webcrypto.subtle.encrypt({ name: \"AES-GCM\", iv }, key, dataBuf);\r\n    const encryptedData2 = \"\" + await arrayBufferToBase64Single(new Uint8Array(encryptedDataArrayBuffer));\r\n    // return data with iv and salt.\r\n    // |%| iv(32) | salt(32) | data ....  \r\n    const ret = `%${uint8ArrayToHexString(iv)}${uint8ArrayToHexString(salt)}${encryptedData2}`;\r\n    return ret;\r\n}\r\n/**\r\n * Generates a key, salt, and IV for obfuscating a path using the provided passphrase.\r\n * @param passphrase - The passphrase used for key generation.\r\n * @param dataBuf - The data buffer to be used in key derivation.\r\n * @param autoCalculateIterations - A flag indicating whether to automatically calculate the number of iterations based on the passphrase length.\r\n * @returns A promise that resolves to an array containing the generated key, salt, and IV.\r\n */\r\nasync function getKeyForObfuscatePath(passphrase: string, dataBuf: Uint8Array, autoCalculateIterations: boolean): Promise<[CryptoKey, Uint8Array, Uint8Array]> {\r\n    const passphraseLen = 15 - passphrase.length;\r\n    const iteration = autoCalculateIterations ? ((passphraseLen > 0 ? passphraseLen : 0) * 1000) + 121 - passphraseLen : 100000;\r\n    const passphraseBin = new TextEncoder().encode(passphrase);\r\n    const digest = await webcrypto.subtle.digest({ name: \"SHA-256\" }, passphraseBin);\r\n    const buf2 = new Uint8Array(await webcrypto.subtle.digest({ name: \"SHA-256\" }, new Uint8Array([...dataBuf, ...passphraseBin])));\r\n    const salt = buf2.slice(0, 16);\r\n    const iv = buf2.slice(16, 32);\r\n    const keyMaterial = await webcrypto.subtle.importKey(\"raw\", digest, { name: \"PBKDF2\" }, false, [\"deriveKey\"]);\r\n    const key = await webcrypto.subtle.deriveKey(\r\n        {\r\n            name: \"PBKDF2\",\r\n            salt,\r\n            iterations: iteration,\r\n            hash: \"SHA-256\",\r\n        },\r\n        keyMaterial,\r\n        { name: \"AES-GCM\", length: 256 },\r\n        false,\r\n        [\"encrypt\"]\r\n    );\r\n    return [key, salt, iv];\r\n}\r\n/**\r\n * Obfuscates the given path using AES-GCM encryption. This obfuscation is deterministic.\r\n * @param path - The path to obfuscate.\r\n * @param passphrase - The passphrase used for encryption.\r\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the iterations.\r\n * @returns The obfuscated path: |%| iv(32) | salt(32) | data ....  \r\n */\r\nexport async function obfuscatePath<T extends string>(path: T, passphrase: string, autoCalculateIterations: boolean) {\r\n    const dataBuf = writeString(path)\r\n    const [key, salt, iv] = await getKeyForObfuscatePath(passphrase, dataBuf, autoCalculateIterations);\r\n    const encryptedDataArrayBuffer = await webcrypto.subtle.encrypt(\r\n        {\r\n            name: \"AES-GCM\",\r\n            iv: iv,\r\n        },\r\n        key,\r\n        dataBuf,\r\n    );\r\n    const encryptedData2 = await arrayBufferToBase64Single(new Uint8Array(encryptedDataArrayBuffer));\r\n    // return data with iv and salt.\r\n    // |%| iv(32) | salt(32) | data ....  \r\n    const ret = `%${uint8ArrayToHexString(iv)}${uint8ArrayToHexString(salt)}${encryptedData2}`;\r\n    return ret;\r\n}\r\n\r\n\r\n/**\r\n * Checks if a given path is probably obfuscated.\r\n * \r\n * @param path - The path to check.\r\n * @returns `true` if the path is probably obfuscated, `false` otherwise.\r\n */\r\nexport function isPathProbablyObfuscated(path: string) {\r\n    return path.startsWith(\"%\") && path.length > 64;\r\n}\r\n\r\n/**\r\n * Decrypts the encrypted result using the provided passphrase and returns the decrypted string.\r\n * @param encryptedResult - The encrypted result to decrypt.\r\n * @param passphrase - The passphrase used for decryption.\r\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the iterations for key derivation.\r\n * @returns A Promise that resolves to the decrypted string.\r\n * @throws If decryption fails or an error occurs during the decryption process.\r\n */\r\nasync function decryptV2(encryptedResult: string, passphrase: string, autoCalculateIterations: boolean): Promise<string> {\r\n    try {\r\n        const ivStr = encryptedResult.substring(1, 33);\r\n        const salt = encryptedResult.substring(33, 65);\r\n        const encryptedData = encryptedResult.substring(65);\r\n        const [key] = await getKeyForDecryption(passphrase, hexStringToUint8Array(salt), autoCalculateIterations);\r\n        const iv = hexStringToUint8Array(ivStr);\r\n        const encryptedDataArrayBuffer = decodeBinary(encryptedData)\r\n        const dataBuffer = await webcrypto.subtle.decrypt({ name: \"AES-GCM\", iv }, key, encryptedDataArrayBuffer);\r\n        const plain = readString(new Uint8Array(dataBuffer));\r\n        return plain;\r\n    } catch (ex) {\r\n        Logger(\"Couldn't decode! You should wrong the passphrases (V2)\", LOG_LEVEL_VERBOSE);\r\n        Logger(ex, LOG_LEVEL_VERBOSE);\r\n        throw ex;\r\n    }\r\n}\r\n\r\n/**\r\n * Decrypts the encrypted result using the provided passphrase.\r\n * @param encryptedResult - The encrypted result to decrypt.\r\n * @param passphrase - The passphrase used for decryption.\r\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the iterations.\r\n * @returns A Promise that resolves to the decrypted string.\r\n * @throws If the encrypted data is corrupted or if decryption fails.\r\n */\r\nexport async function decrypt(encryptedResult: string, passphrase: string, autoCalculateIterations: boolean): Promise<string> {\r\n    try {\r\n        if (encryptedResult[0] == \"%\") {\r\n            if (encryptedResult[1] === \"~\") {\r\n                return decryptV3(encryptedResult, passphrase);\r\n            }\r\n            return decryptV2(encryptedResult, passphrase, autoCalculateIterations);\r\n        }\r\n        if (!encryptedResult.startsWith(\"[\") || !encryptedResult.endsWith(\"]\")) {\r\n            throw new Error(\"Encrypted data corrupted!\");\r\n        }\r\n        const w: any = encryptedResult.substring(1, encryptedResult.length - 1).split(\",\").map(e => e[0] == '\"' ? e.substring(1, e.length - 1) : e);\r\n        const [encryptedData, ivString, salt]: encodedData = w;\r\n        const [key] = await getKeyForDecryption(passphrase, hexStringToUint8Array(salt), autoCalculateIterations);\r\n        const iv = hexStringToUint8Array(ivString);\r\n        // decode base 64, it should increase speed and i should with in MAX_DOC_SIZE_BIN, so it won't OOM.\r\n        const encryptedDataBin = atob(encryptedData);\r\n        const len = encryptedDataBin.length;\r\n        const encryptedDataArrayBuffer = new Uint8Array(len);\r\n        // converting binary string to arraybuffer\r\n        for (let i = len; i >= 0; --i) {\r\n            encryptedDataArrayBuffer[i] = encryptedDataBin.charCodeAt(i);\r\n        }\r\n        const plainStringBuffer: ArrayBuffer = await webcrypto.subtle.decrypt({ name: \"AES-GCM\", iv }, key, encryptedDataArrayBuffer);\r\n        const plainStringified = readString(new Uint8Array(plainStringBuffer));\r\n        const plain = JSON.parse(plainStringified);\r\n        return plain;\r\n    } catch (ex) {\r\n        Logger(\"Couldn't decode! You should wrong the passphrases\", LOG_LEVEL_VERBOSE);\r\n        Logger(ex, LOG_LEVEL_VERBOSE);\r\n        throw ex;\r\n    }\r\n}\r\n\r\n/**\r\n * Tries to decrypt the encrypted result using the provided passphrase.\r\n * \r\n * @param encryptedResult - The encrypted result to decrypt.\r\n * @param passphrase - The passphrase used for decryption.\r\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the iterations.\r\n * @returns A promise that resolves to the decrypted result if successful, or `false` if decryption fails.\r\n */\r\nexport async function tryDecrypt(encryptedResult: string, passphrase: string | false, autoCalculateIterations: boolean): Promise<string | false> {\r\n    if (!passphrase) return false;\r\n    try {\r\n        return await decrypt(encryptedResult, passphrase, autoCalculateIterations);\r\n    } catch (ex) {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport async function testCryptV3() {\r\n    const src = \"✨supercalifragilisticexpialidocious✨⛰️\";\r\n    const encoded = await encryptV3(src, \"passwordTest\");\r\n    const decrypted = await decrypt(encoded, \"passwordTest\", false);\r\n    if (src != decrypted) {\r\n        Logger(\"WARNING! Your device would not support encryption V3.\", LOG_LEVEL_VERBOSE);\r\n        return false;\r\n    } else {\r\n        Logger(\"CRYPT LOGIC (V3) OK\", LOG_LEVEL_VERBOSE);\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Tests the encryption and decryption functionality.\r\n * @returns {Promise<boolean>} A promise that resolves to `true` if encryption and decryption are successful, and `false` otherwise.\r\n */\r\nexport async function testCrypt() {\r\n    const src = \"✨supercalifragilisticexpialidocious✨⛰️\";\r\n\r\n    const encoded = await encrypt(src, \"passwordTest\", false);\r\n    const decrypted = await decrypt(encoded, \"passwordTest\", false);\r\n    if (src != decrypted) {\r\n        Logger(\"WARNING! Your device would not support encryption.\", LOG_LEVEL_VERBOSE);\r\n        return false;\r\n    } else {\r\n        Logger(\"CRYPT LOGIC OK\", LOG_LEVEL_VERBOSE);\r\n        const w = new TextEncoder().encode(src);\r\n        const encodedBinary = await encryptBinary(w, \"passwordTest\", false);\r\n        const decryptedBinary = await decryptBinary(encodedBinary, \"passwordTest\", false);\r\n\r\n        if (w.join(\"-\") !== decryptedBinary.join(\"-\")) {\r\n            Logger(\"WARNING! Your device would not support encryption (Binary).\", LOG_LEVEL_VERBOSE);\r\n            return false;\r\n        } else {\r\n            Logger(\"CRYPT LOGIC OK (Binary)\", LOG_LEVEL_VERBOSE);\r\n        }\r\n        return await testCryptV3();\r\n    }\r\n}\r\n\r\n/**\r\n * Encrypts binary data using AES-GCM encryption algorithm.\r\n * \r\n * @param input - The binary data to be encrypted.\r\n * @param passphrase - The passphrase used to derive the encryption key.\r\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the number of iterations for key derivation.\r\n * @returns The encrypted binary data.\r\n */\r\nexport async function encryptBinary(input: Uint8Array, passphrase: string, autoCalculateIterations: boolean) {\r\n    const [key, salt] = await getKeyForEncrypt(passphrase, autoCalculateIterations);\r\n    // Create initial vector with semi-fixed part and incremental part\r\n    // I think it's not good against related-key attacks.\r\n    const fixedPart = getSemiStaticField();\r\n    const invocationPart = getNonce();\r\n    const iv = new Uint8Array([...fixedPart, ...new Uint8Array(invocationPart.buffer)]);\r\n    const dataBuf = input\r\n    const encryptedDataArrayBuffer = new Uint8Array(await webcrypto.subtle.encrypt({ name: \"AES-GCM\", iv }, key, dataBuf));\r\n    const ret = new Uint8Array(encryptedDataArrayBuffer.byteLength + iv.byteLength + salt.byteLength);\r\n    ret.set(iv, 0);\r\n    ret.set(salt, iv.byteLength);\r\n    ret.set(encryptedDataArrayBuffer, iv.byteLength + salt.byteLength);\r\n    return ret;\r\n}\r\n/**\r\n * Decrypts the encrypted binary data using the provided passphrase.\r\n * @param encryptedResult - The encrypted binary data as a Uint8Array.\r\n * @param passphrase - The passphrase used for decryption.\r\n * @param autoCalculateIterations - A boolean indicating whether to automatically calculate the iterations for key derivation.\r\n * @returns A Promise that resolves to the decrypted binary data as a Uint8Array.\r\n * @throws If decryption fails or an error occurs during the decryption process.\r\n */\r\nexport async function decryptBinary(encryptedResult: Uint8Array, passphrase: string, autoCalculateIterations: boolean): Promise<Uint8Array> {\r\n    try {\r\n        const iv = encryptedResult.slice(0, 16);\r\n        const salt = encryptedResult.slice(16, 32);\r\n        const encryptedData = encryptedResult.slice(32);\r\n        const [key] = await getKeyForDecryption(passphrase, salt, autoCalculateIterations);\r\n        const dataBuffer = await webcrypto.subtle.decrypt({ name: \"AES-GCM\", iv }, key, encryptedData);\r\n        return new Uint8Array(dataBuffer)\r\n    } catch (ex) {\r\n        Logger(\"Couldn't decode! You should wrong the passphrases (V2 Bin)\", LOG_LEVEL_VERBOSE);\r\n        Logger(ex, LOG_LEVEL_VERBOSE);\r\n        throw ex;\r\n    }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}