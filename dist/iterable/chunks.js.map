{"version":3,"file":"chunks.js","sources":["../../src/iterable/chunks.ts"],"sourcesContent":["import { GeneratorSource } from \"./source\";\n\ntype ChunkProcessOptions = {\n    /**\n     * The number of items to be packed into a single chunk.\n     */\n    unit: number;\n    /**\n     * The maximum time to wait for the next chunk to be filled.\n     * If the timeout is reached, the current chunk will be yielded partially.\n     * This counted from the last item has been enqueued.\n     * Empty chunks will not be yielded.\n     */\n    timeout?: number;\n    /**\n     * The minimum time to wait before yielding the next chunk.\n     * If chunks are filled before the interval passes, yielding will be delayed.\n     * This counted from the last chunk has been yielded.\n     */\n    interval?: number;\n};\nconst FINISHED = Symbol(\"finished\");\n\n/**\n * async generator that yields chunks of items from the source.\n * @param source\n * @param {ChunkProcessOptions} options\n */\nexport async function* asChunk<T>(source: Iterable<T> | AsyncIterable<T>, { unit, timeout, interval }: ChunkProcessOptions): AsyncIterable<T[]> {\n    const outputSource = new GeneratorSource<T[] | typeof FINISHED>();\n    const pBuffer: T[] = [];\n    let previousYielded = 0;\n    let timeoutTimer: ReturnType<typeof setTimeout> | undefined = undefined;\n\n    const scheduleTimeout = () => {\n        if (timeout) {\n            if (!timeoutTimer) {\n                clearTimeout(timeoutTimer);\n            }\n            timeoutTimer = setTimeout(() => {\n                flush(false);\n                timeoutTimer = undefined;\n            }, timeout);\n        }\n    };\n    const enqueueItem = (item: T) => {\n        pBuffer.push(item);\n        if (pBuffer.length >= unit) {\n            flush(false);\n        }\n    };\n    const flush = (done: boolean) => {\n        const flushTo = done ? 0 : unit;\n        while (pBuffer.length >= flushTo) {\n            const chunk = pBuffer.splice(0, unit);\n            if (chunk.length === 0) {\n                break;\n            }\n            outputSource.enqueue(chunk);\n        }\n        if (done) {\n            outputSource.enqueue(FINISHED);\n        }\n    };\n\n    void (async () => {\n        for await (const item of source) {\n            enqueueItem(item);\n        }\n        flush(true);\n    })();\n\n    for await (const chunk of outputSource) {\n        if (chunk === FINISHED) {\n            break;\n        }\n        scheduleTimeout();\n        if (interval) {\n            const now = Date.now();\n            const elapsed = now - previousYielded;\n            if (elapsed < interval) {\n                await new Promise(resolve => setTimeout(resolve, interval - elapsed));\n            }\n        }\n        yield chunk;\n        previousYielded = Date.now();\n    }\n    // Cleanup\n    if (timeoutTimer) {\n        clearTimeout(timeoutTimer);\n    }\n    outputSource.dispose();\n}\n\n/**\n * Flattens nested async or sync iterables.\n * The counterpart to `asChunk`.\n * @param source \n */\nexport async function* asFlat<T>(source: AsyncIterable<AsyncIterable<T> | Iterable<T>>): AsyncIterable<T> {\n    for await (const chunk of source) {\n        for await (const item of chunk) {\n            yield item;\n        }\n    }\n}"],"names":[],"mappings":";;AAqBA,MAAM,QAAQ,GAAG,MAAM,CAAC,UAAU,CAAC;AAEnC;;;;AAIG;AACI,gBAAgB,OAAO,CAAI,MAAsC,EAAE,EAAE,IAAI,EAAE,OAAO,EAAE,QAAQ,EAAuB,EAAA;AACtH,IAAA,MAAM,YAAY,GAAG,IAAI,eAAe,EAAyB;IACjE,MAAM,OAAO,GAAQ,EAAE;IACvB,IAAI,eAAe,GAAG,CAAC;IACvB,IAAI,YAAY,GAA8C,SAAS;IAEvE,MAAM,eAAe,GAAG,MAAK;QACzB,IAAI,OAAO,EAAE;YACT,IAAI,CAAC,YAAY,EAAE;gBACf,YAAY,CAAC,YAAY,CAAC;;AAE9B,YAAA,YAAY,GAAG,UAAU,CAAC,MAAK;gBAC3B,KAAK,CAAC,KAAK,CAAC;gBACZ,YAAY,GAAG,SAAS;aAC3B,EAAE,OAAO,CAAC;;AAEnB,KAAC;AACD,IAAA,MAAM,WAAW,GAAG,CAAC,IAAO,KAAI;AAC5B,QAAA,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC;AAClB,QAAA,IAAI,OAAO,CAAC,MAAM,IAAI,IAAI,EAAE;YACxB,KAAK,CAAC,KAAK,CAAC;;AAEpB,KAAC;AACD,IAAA,MAAM,KAAK,GAAG,CAAC,IAAa,KAAI;QAC5B,MAAM,OAAO,GAAG,IAAI,GAAG,CAAC,GAAG,IAAI;AAC/B,QAAA,OAAO,OAAO,CAAC,MAAM,IAAI,OAAO,EAAE;YAC9B,MAAM,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC;AACrC,YAAA,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;gBACpB;;AAEJ,YAAA,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC;;QAE/B,IAAI,IAAI,EAAE;AACN,YAAA,YAAY,CAAC,OAAO,CAAC,QAAQ,CAAC;;AAEtC,KAAC;IAED,KAAK,CAAC,YAAW;AACb,QAAA,WAAW,MAAM,IAAI,IAAI,MAAM,EAAE;YAC7B,WAAW,CAAC,IAAI,CAAC;;QAErB,KAAK,CAAC,IAAI,CAAC;KACd,GAAG;AAEJ,IAAA,WAAW,MAAM,KAAK,IAAI,YAAY,EAAE;AACpC,QAAA,IAAI,KAAK,KAAK,QAAQ,EAAE;YACpB;;AAEJ,QAAA,eAAe,EAAE;QACjB,IAAI,QAAQ,EAAE;AACV,YAAA,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE;AACtB,YAAA,MAAM,OAAO,GAAG,GAAG,GAAG,eAAe;AACrC,YAAA,IAAI,OAAO,GAAG,QAAQ,EAAE;AACpB,gBAAA,MAAM,IAAI,OAAO,CAAC,OAAO,IAAI,UAAU,CAAC,OAAO,EAAE,QAAQ,GAAG,OAAO,CAAC,CAAC;;;AAG7E,QAAA,MAAM,KAAK;AACX,QAAA,eAAe,GAAG,IAAI,CAAC,GAAG,EAAE;;;IAGhC,IAAI,YAAY,EAAE;QACd,YAAY,CAAC,YAAY,CAAC;;IAE9B,YAAY,CAAC,OAAO,EAAE;AAC1B;AAEA;;;;AAIG;AACI,gBAAgB,MAAM,CAAI,MAAqD,EAAA;AAClF,IAAA,WAAW,MAAM,KAAK,IAAI,MAAM,EAAE;AAC9B,QAAA,WAAW,MAAM,IAAI,IAAI,KAAK,EAAE;AAC5B,YAAA,MAAM,IAAI;;;AAGtB;;;;"}