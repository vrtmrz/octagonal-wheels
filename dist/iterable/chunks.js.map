{"version":3,"file":"chunks.js","sources":["../../src/iterable/chunks.ts"],"sourcesContent":["import { PaceMaker } from \"../bureau/PaceMaker\";\nimport { NOT_AVAILABLE, InboxWithEvent } from \"../bureau/Inbox\";\nimport { Feeder, Porter } from \"../bureau/Clerk\";\nimport { promiseWithResolver } from \"../promises\";\n\ntype ChunkProcessOptions = {\n    /**\n     * The number of items to be packed into a single chunk.\n     */\n    unit: number;\n\n    /**\n     * The maximum time to wait for the next chunk to be filled.\n     * If the timeout is reached, the current chunk will be yielded partially.\n     * This counted from the last item has been enqueued.\n     * Empty chunks will not be yielded.\n     */\n    timeout?: number;\n    /**\n     * The minimum time to wait before yielding the next chunk.\n     * If chunks are filled before the interval passes, yielding will be delayed.\n     * This counted from the last chunk has been yielded.\n     */\n    interval?: number;\n};\n\n\n/**\n * async generator that yields chunks of items from the source.\n * @param source\n * @param {ChunkProcessOptions} options\n */\nexport async function* asChunk<T>(source: Iterable<T> | AsyncIterable<T>, { unit, timeout, interval }: ChunkProcessOptions): AsyncIterable<T[]> {\n    const postBox = new InboxWithEvent<T>(unit * 10);\n    const outgoingBox = new InboxWithEvent<T[]>(10);\n    const completed = promiseWithResolver<void>();\n    const pacemaker = interval ? new PaceMaker(interval) : undefined;\n    let isCompleted = false;\n\n\n    const porter = new Porter(\n        {\n            from: postBox, to: outgoingBox,\n            timeout: timeout,\n            maxSize: unit,\n        },\n    );\n    const feeder = new Feeder({\n        source, target: postBox,\n    });\n    const checkStates = () => {\n        if (porter.stateDetail.isBusy) return;\n        // if (harvester.stateDetail.isBusy) return;\n        if (!feeder.stateDetail.hasFinished) return;\n        if (outgoingBox.size != 0) return;\n        isCompleted = true;\n        completed.resolve();\n    };\n    feeder.setOnProgress((state) => {\n        checkStates();\n    });\n    porter.setOnProgress((state) => {\n        checkStates();\n    });\n    postBox.setOnProgress((state) => {\n        checkStates();\n    });\n    outgoingBox.setOnProgress((state) => {\n        checkStates();\n    });\n\n    do {\n        const chunk = await outgoingBox.pick(undefined, [completed.promise]);\n        if (chunk === NOT_AVAILABLE) {\n            if (isCompleted) {\n                break;\n            }\n            continue;\n        }\n\n        if (pacemaker) {\n            await Promise.race([pacemaker.paced]);\n        }\n\n        yield chunk;\n        pacemaker?.mark();\n\n    } while (!isCompleted);\n    porter.dispose();\n}\n\n/**\n * Flattens nested async or sync iterables.\n * The counterpart to `asChunk`.\n * @param source \n */\nexport async function* asFlat<T>(source: AsyncIterable<AsyncIterable<T> | Iterable<T>>): AsyncIterable<T> {\n    for await (const chunk of source) {\n        for await (const item of chunk) {\n            yield item;\n        }\n    }\n}"],"names":[],"mappings":";;;;;AA2BA;;;;AAIG;AACI,gBAAgB,OAAO,CAAI,MAAsC,EAAE,EAAE,IAAI,EAAE,OAAO,EAAE,QAAQ,EAAuB,EAAA;IACtH,MAAM,OAAO,GAAG,IAAI,cAAc,CAAI,IAAI,GAAG,EAAE,CAAC;AAChD,IAAA,MAAM,WAAW,GAAG,IAAI,cAAc,CAAM,EAAE,CAAC;AAC/C,IAAA,MAAM,SAAS,GAAG,mBAAmB,EAAQ;AAC7C,IAAA,MAAM,SAAS,GAAG,QAAQ,GAAG,IAAI,SAAS,CAAC,QAAQ,CAAC,GAAG,SAAS;IAChE,IAAI,WAAW,GAAG,KAAK;AAGvB,IAAA,MAAM,MAAM,GAAG,IAAI,MAAM,CACrB;AACI,QAAA,IAAI,EAAE,OAAO,EAAE,EAAE,EAAE,WAAW;AAC9B,QAAA,OAAO,EAAE,OAAO;AAChB,QAAA,OAAO,EAAE,IAAI;AAChB,KAAA,CACJ;AACD,IAAA,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC;QACtB,MAAM,EAAE,MAAM,EAAE,OAAO;AAC1B,KAAA,CAAC;IACF,MAAM,WAAW,GAAG,MAAK;AACrB,QAAA,IAAI,MAAM,CAAC,WAAW,CAAC,MAAM;YAAE;;AAE/B,QAAA,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,WAAW;YAAE;AACrC,QAAA,IAAI,WAAW,CAAC,IAAI,IAAI,CAAC;YAAE;QAC3B,WAAW,GAAG,IAAI;QAClB,SAAS,CAAC,OAAO,EAAE;AACvB,KAAC;AACD,IAAA,MAAM,CAAC,aAAa,CAAC,CAAC,KAAK,KAAI;AAC3B,QAAA,WAAW,EAAE;AACjB,KAAC,CAAC;AACF,IAAA,MAAM,CAAC,aAAa,CAAC,CAAC,KAAK,KAAI;AAC3B,QAAA,WAAW,EAAE;AACjB,KAAC,CAAC;AACF,IAAA,OAAO,CAAC,aAAa,CAAC,CAAC,KAAK,KAAI;AAC5B,QAAA,WAAW,EAAE;AACjB,KAAC,CAAC;AACF,IAAA,WAAW,CAAC,aAAa,CAAC,CAAC,KAAK,KAAI;AAChC,QAAA,WAAW,EAAE;AACjB,KAAC,CAAC;AAEF,IAAA,GAAG;AACC,QAAA,MAAM,KAAK,GAAG,MAAM,WAAW,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;AACpE,QAAA,IAAI,KAAK,KAAK,aAAa,EAAE;YACzB,IAAI,WAAW,EAAE;gBACb;;YAEJ;;QAGJ,IAAI,SAAS,EAAE;YACX,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;;AAGzC,QAAA,MAAM,KAAK;QACX,SAAS,EAAE,IAAI,EAAE;KAEpB,QAAQ,CAAC,WAAW;IACrB,MAAM,CAAC,OAAO,EAAE;AACpB;AAEA;;;;AAIG;AACI,gBAAgB,MAAM,CAAI,MAAqD,EAAA;AAClF,IAAA,WAAW,MAAM,KAAK,IAAI,MAAM,EAAE;AAC9B,QAAA,WAAW,MAAM,IAAI,IAAI,KAAK,EAAE;AAC5B,YAAA,MAAM,IAAI;;;AAGtB;;;;"}