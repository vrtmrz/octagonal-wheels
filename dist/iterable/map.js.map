{"version":3,"file":"map.js","sources":["../../src/iterable/map.ts"],"sourcesContent":["async function* withIndex<T>(iterable: Iterable<T> | AsyncIterableIterator<T>): AsyncIterableIterator<[number, T]> {\n    let order = 0;\n    for await (const t of iterable) {\n        yield [order++, t];\n    }\n}\n\n/**\n * apply a function to each element of an iterable asynchronously with a concurrency limit.\n * Note that the order of the elements is not guaranteed.\n * @param iterable An iterable items to be processed.\n * @param callback A function to be applied to each element of the iterable.\n * @param concurrency The number of concurrent processes.\n */\nexport async function* withConcurrency<T, U>(iterable: Iterable<T> | AsyncIterableIterator<T>, callback: (t: T) => Promise<U>, concurrency: number): AsyncIterableIterator<U> {\n    const processes = new Set<Promise<[number, U]>>();\n    const mapTaskToPromise = new Map<number, Promise<[number, U]>>();\n    let serial = 0;\n    const enqueue = (item: T) => {\n        const idx = serial++;\n        const promise = (async () => [idx, await callback(item) as U] as [number, U])();\n        processes.add(promise);\n        mapTaskToPromise.set(idx, promise);\n    };\n    const consume = async () => {\n        const r = await Promise.race(processes);\n        const item = mapTaskToPromise.get(r[0])!;\n        processes.delete(item);\n        mapTaskToPromise.delete(r[0]);\n        return r[1];\n\n    };\n    for await (const t of iterable) {\n        while (processes.size >= concurrency) {\n            yield await consume();\n        }\n        enqueue(t);\n    }\n    while (processes.size > 0) {\n        yield await consume();\n    }\n}\n\n/**\n * Just like an filter function in the Array, but this function is asynchronous.\n * @param iterable Source iterable.\n * @param callback Filtering function.\n */\nexport async function* filter<T>(iterable: Iterable<T> | AsyncIterableIterator<T>, callback: (t: T) => boolean | Promise<boolean>): AsyncIterableIterator<T> {\n    for await (const t of iterable) {\n        if (await callback(t)) {\n            yield t;\n        }\n    }\n}\n\n/**\n * apply a function to each element of an iterable asynchronously, as keeping the order of the elements.\n * @param iterable an iterable items to be processed.\n * @param callback a function to be applied to each element of the iterable.\n * @param concurrency  the number of concurrent processes.\n */\nexport async function* asyncMapWithConcurrency<T, U>(iterable: Iterable<T> | AsyncIterableIterator<T>, callback: (t: T) => Promise<U>, concurrency: number): AsyncIterableIterator<U> {\n    const buffer = new Map<number, U>();\n    let head = 0;\n    const source = withConcurrency(withIndex(iterable), async ([index, value]) => {\n        return [index, await callback(value)] as const;\n    }, concurrency);\n    for await (const t of source) {\n        const [index, value] = t;\n        buffer.set(index, value);\n        while (buffer.has(head)) {\n            yield buffer.get(head) as U;\n            buffer.delete(head);\n            head++;\n        }\n    }\n    while (buffer.has(head)) {\n        yield buffer.get(head) as U;\n        buffer.delete(head);\n        head++;\n    }\n    if (buffer.size > 0) {\n        throw new Error('Buffer not empty');\n    }\n}\n"],"names":[],"mappings":"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"}