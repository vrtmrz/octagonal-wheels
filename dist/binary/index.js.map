{"version":3,"file":"index.js","sources":["../../src/binary/index.ts"],"sourcesContent":["import { arrayBufferToBase64, base64ToArrayBuffer } from \"./base64\";\r\nimport { _decodeToArrayBuffer, decodeToArrayBuffer } from \"./encodedUTF16\";\r\n\r\n/**\r\n * Concatenates multiple Uint8Array arrays into a single Uint8Array.\r\n * \r\n * @param arrays - An array of Uint8Array arrays to be concatenated.\r\n * @returns A new Uint8Array containing the concatenated values.\r\n */\r\nexport function concatUInt8Array(arrays: Uint8Array[]): Uint8Array {\r\n    const length = arrays.reduce((acc, cur) => acc + cur.length, 0);\r\n    const result = new Uint8Array(length);\r\n    let pos = 0;\r\n    for (const array of arrays) {\r\n        result.set(array, pos);\r\n        pos += array.length;\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Decodes a binary string or an array of binary strings into an ArrayBuffer.\r\n * If the input is an empty string or array, it returns an empty ArrayBuffer.\r\n * If the input starts with '%', it decodes the string(s) using `_decodeToArrayBuffer` function.\r\n * Otherwise, it decodes the string(s) using `base64ToArrayBuffer` function.\r\n * \r\n * @param src - The binary string or array of binary strings to decode.\r\n * @returns The decoded ArrayBuffer.\r\n * @remarks Now, Self-hosted LiveSync always use base64 for encoding/decoding.\r\n */\r\nexport function decodeBinary(src: string | string[]) {\r\n    if (src.length == 0) return new Uint8Array().buffer;\r\n    if (typeof src === \"string\") {\r\n        if (src[0] === \"%\") {\r\n            return _decodeToArrayBuffer(src.substring(1));\r\n        }\r\n    } else {\r\n        if (src[0][0] === \"%\") {\r\n            const [head, ...last] = src;\r\n            return decodeToArrayBuffer([head.substring(1), ...last]);\r\n        }\r\n    }\r\n    return base64ToArrayBuffer(src);\r\n}\r\n\r\n/**\r\n * Encodes a binary data into a string array using base64 encoding.\r\n * \r\n * @param src - The binary data to be encoded. It can be either a Uint8Array or an ArrayBuffer.\r\n * @returns A promise that resolves to a string array representing the encoded binary data.\r\n */\r\nexport async function encodeBinary(src: Uint8Array | ArrayBuffer): Promise<string[]> {\r\n    return await arrayBufferToBase64(src);\r\n}\r\n\r\n\r\nexport * from \"./base64\";\r\nexport * from \"./encodedUTF16\";\r\nexport * from \"./hex\";"],"names":[],"mappings":";;;;;;AAGA;;;;;AAKG;AACG,SAAU,gBAAgB,CAAC,MAAoB,EAAA;IACjD,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,KAAK,GAAG,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;AAChE,IAAA,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC;IACtC,IAAI,GAAG,GAAG,CAAC,CAAC;AACZ,IAAA,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;AACxB,QAAA,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AACvB,QAAA,GAAG,IAAI,KAAK,CAAC,MAAM,CAAC;KACvB;AACD,IAAA,OAAO,MAAM,CAAC;AAClB,CAAC;AAED;;;;;;;;;AASG;AACG,SAAU,YAAY,CAAC,GAAsB,EAAA;AAC/C,IAAA,IAAI,GAAG,CAAC,MAAM,IAAI,CAAC;AAAE,QAAA,OAAO,IAAI,UAAU,EAAE,CAAC,MAAM,CAAC;AACpD,IAAA,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;AACzB,QAAA,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YAChB,OAAO,oBAAoB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;SACjD;KACJ;SAAM;QACH,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YACnB,MAAM,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,GAAG,CAAC;AAC5B,YAAA,OAAO,mBAAmB,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC;SAC5D;KACJ;AACD,IAAA,OAAO,mBAAmB,CAAC,GAAG,CAAC,CAAC;AACpC,CAAC;AAED;;;;;AAKG;AACI,eAAe,YAAY,CAAC,GAA6B,EAAA;AAC5D,IAAA,OAAO,MAAM,mBAAmB,CAAC,GAAG,CAAC,CAAC;AAC1C;;;;"}