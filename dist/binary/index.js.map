{"version":3,"file":"index.js","sources":["../../src/binary/index.ts"],"sourcesContent":["import { arrayBufferToBase64, base64ToArrayBuffer } from \"./base64\";\nimport { _decodeToArrayBuffer, decodeToArrayBuffer } from \"./encodedUTF16\";\n\n/**\n * Concatenates multiple Uint8Array arrays into a single Uint8Array.\n * \n * @param arrays - An array of Uint8Array arrays to be concatenated.\n * @returns A new Uint8Array containing the concatenated values.\n */\nexport function concatUInt8Array(arrays: Uint8Array[]): Uint8Array {\n    const length = arrays.reduce((acc, cur) => acc + cur.length, 0);\n    const result = new Uint8Array(length);\n    let pos = 0;\n    for (const array of arrays) {\n        result.set(array, pos);\n        pos += array.length;\n    }\n    return result;\n}\n\n/**\n * Decodes a binary string or an array of binary strings into an ArrayBuffer.\n * If the input is an empty string or array, it returns an empty ArrayBuffer.\n * If the input starts with '%', it decodes the string(s) using `_decodeToArrayBuffer` function.\n * Otherwise, it decodes the string(s) using `base64ToArrayBuffer` function.\n * \n * @param src - The binary string or array of binary strings to decode.\n * @returns The decoded ArrayBuffer.\n * @remarks Now, Self-hosted LiveSync always use base64 for encoding/decoding.\n */\nexport function decodeBinary(src: string | string[]) {\n    if (src.length == 0) return new Uint8Array().buffer;\n    if (typeof src === \"string\") {\n        if (src[0] === \"%\") {\n            return _decodeToArrayBuffer(src.substring(1));\n        }\n    } else {\n        if (src[0][0] === \"%\") {\n            const [head, ...last] = src;\n            return decodeToArrayBuffer([head.substring(1), ...last]);\n        }\n    }\n    return base64ToArrayBuffer(src);\n}\n\n/**\n * Encodes a binary data into a string array using base64 encoding.\n * \n * @param src - The binary data to be encoded. It can be either a Uint8Array or an ArrayBuffer.\n * @returns A promise that resolves to a string array representing the encoded binary data.\n */\nexport async function encodeBinary(src: Uint8Array | ArrayBuffer): Promise<string[]> {\n    return await arrayBufferToBase64(src);\n}\n\n\nexport * from \"./base64\";\nexport * from \"./encodedUTF16\";\nexport * from \"./hex\";"],"names":[],"mappings":";;;;;;AAGA;;;;;AAKG;AACG,SAAU,gBAAgB,CAAC,MAAoB,EAAA;IACjD,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,KAAK,GAAG,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC;AAC/D,IAAA,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC;IACrC,IAAI,GAAG,GAAG,CAAC;AACX,IAAA,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;AACxB,QAAA,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC;AACtB,QAAA,GAAG,IAAI,KAAK,CAAC,MAAM;;AAEvB,IAAA,OAAO,MAAM;AACjB;AAEA;;;;;;;;;AASG;AACG,SAAU,YAAY,CAAC,GAAsB,EAAA;AAC/C,IAAA,IAAI,GAAG,CAAC,MAAM,IAAI,CAAC;AAAE,QAAA,OAAO,IAAI,UAAU,EAAE,CAAC,MAAM;AACnD,IAAA,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;AACzB,QAAA,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YAChB,OAAO,oBAAoB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;;;SAE9C;QACH,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YACnB,MAAM,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,GAAG;AAC3B,YAAA,OAAO,mBAAmB,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,CAAC;;;AAGhE,IAAA,OAAO,mBAAmB,CAAC,GAAG,CAAC;AACnC;AAEA;;;;;AAKG;AACI,eAAe,YAAY,CAAC,GAA6B,EAAA;AAC5D,IAAA,OAAO,MAAM,mBAAmB,CAAC,GAAG,CAAC;AACzC;;;;"}