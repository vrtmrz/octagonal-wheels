{"version":3,"file":"base64.js","sources":["../../src/binary/base64.ts"],"sourcesContent":["import { Logger, LOG_LEVEL_VERBOSE } from \"../common/logger\";\r\n/**\r\n * Converts a base64 string or an array of base64 strings to an ArrayBuffer.\r\n * @param base64 - The base64 string or an array of base64 strings to convert.\r\n * @returns The converted ArrayBuffer.\r\n */\r\nexport function base64ToArrayBuffer(base64: string | string[]): ArrayBuffer {\r\n    if (typeof (base64) == \"string\") return base64ToArrayBufferInternalBrowser(base64);\r\n    const bufItems = base64.map(e => base64ToArrayBufferInternalBrowser(e));\r\n    const len = bufItems.reduce((p, c) => p + c.byteLength, 0);\r\n    const joinedArray = new Uint8Array(len);\r\n    let offset = 0;\r\n    bufItems.forEach(e => {\r\n        joinedArray.set(new Uint8Array(e), offset);\r\n        offset += e.byteLength;\r\n    });\r\n    return joinedArray.buffer;\r\n}\r\n\r\n\r\n/**\r\n * Converts a base64 string to an ArrayBuffer in a browser environment.\r\n * \r\n * @param base64 - The base64 string to convert.\r\n * @returns The converted ArrayBuffer.\r\n */\r\nexport function base64ToArrayBufferInternalBrowser(base64: string): ArrayBuffer {\r\n    try {\r\n        const binary_string = globalThis.atob(base64);\r\n        const len = binary_string.length;\r\n        const bytes = new Uint8Array(len);\r\n        for (let i = 0; i < len; i++) {\r\n            bytes[i] = binary_string.charCodeAt(i);\r\n        }\r\n        return bytes.buffer;\r\n    } catch (ex) {\r\n        Logger(\"Base64 Decode error\", LOG_LEVEL_VERBOSE);\r\n        Logger(ex, LOG_LEVEL_VERBOSE);\r\n        return new ArrayBuffer(0);\r\n    }\r\n}\r\n\r\n// Base64 Encoding\r\n\r\nconst encodeChunkSize = 3 * 50000000;\r\n\r\n\r\n/**\r\n * Converts an ArrayBuffer or Uint8Array to a base64-encoded string in a browser environment.\r\n * @param buffer The input buffer to be converted.\r\n * @returns A Promise that resolves to the base64-encoded string.\r\n */\r\nfunction arrayBufferToBase64internalBrowser(buffer: DataView | Uint8Array): Promise<string> {\r\n    return new Promise((res, rej) => {\r\n        const blob = new Blob([buffer], { type: \"application/octet-binary\" });\r\n        const reader = new FileReader();\r\n        reader.onload = function (evt) {\r\n            const dataURI = evt.target?.result?.toString() || \"\";\r\n            if (buffer.byteLength != 0 && (dataURI == \"\" || dataURI == \"data:\")) return rej(new TypeError(\"Could not parse the encoded string\"));\r\n            const result = dataURI.substring(dataURI.indexOf(\",\") + 1);\r\n            res(result);\r\n        };\r\n        reader.readAsDataURL(blob);\r\n    });\r\n}\r\n\r\n/**\r\n * Converts an ArrayBuffer to a base64 string.\r\n * \r\n * @param buffer - The ArrayBuffer to convert.\r\n * @returns A Promise that resolves to the base64 string representation of the ArrayBuffer.\r\n */\r\nexport async function arrayBufferToBase64Single(buffer: ArrayBuffer): Promise<string> {\r\n    const buf = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\r\n    if (buf.byteLength < QUANTUM) return btoa(String.fromCharCode.apply(null, [...buf]));\r\n    return await arrayBufferToBase64internalBrowser(buf);\r\n}\r\n/**\r\n * Converts an ArrayBuffer to a base64 string.\r\n * \r\n * @param buffer - The ArrayBuffer to convert.\r\n * @returns A Promise that resolves to an array of base64 strings.\r\n */\r\nexport async function arrayBufferToBase64(buffer: ArrayBuffer): Promise<string[]> {\r\n    const buf = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\r\n    if (buf.byteLength < QUANTUM) return [btoa(String.fromCharCode.apply(null, [...buf]))];\r\n    const bufLen = buf.byteLength;\r\n    const pieces = [] as string[];\r\n    let idx = 0;\r\n    do {\r\n        const offset = idx * encodeChunkSize;\r\n        const pBuf = new DataView(buf.buffer, offset, Math.min(encodeChunkSize, buf.byteLength - offset));\r\n        pieces.push(await arrayBufferToBase64internalBrowser(pBuf));\r\n        idx++;\r\n    } while (idx * encodeChunkSize < bufLen);\r\n    return pieces;\r\n}\r\n\r\n\r\n//\r\n// Safari's JavaScriptCOre hardcoded the argument limit to 65536\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\r\nconst QUANTUM = 32768;\r\n\r\n/**\r\n *  Super fast Text Encoder / Decoder alternative. \r\n * @param {string} string - The string to convert.\r\n * @returns {Uint8Array} The Uint8Array buffer representing the string.\r\n * @see https://gist.github.com/kawanet/a66a0e2657464c57bcff2249286d3a24\r\n * @see https://qiita.com/kawanet/items/52062b0c86597f7dee7d\r\n * \r\n * remark: This is a super fast TextEncoder alternative.\r\n * todo: When Capacitor or Electron is upgraded, check and reappraise this.\r\n */\r\n\r\nconst te = new TextEncoder();\r\nconst td = new TextDecoder();\r\n\r\nexport function writeString(string: string): Uint8Array {\r\n    // Prepare enough buffer.\r\n    if (string.length > 128) return te.encode(string);\r\n    const buffer = new Uint8Array(string.length * 4);\r\n    const length = string.length;\r\n    let index = 0;\r\n    let chr = 0;\r\n    let idx = 0;\r\n    while (idx < length) {\r\n        chr = string.charCodeAt(idx++);\r\n        if (chr < 128) {\r\n            buffer[index++] = chr;\r\n        } else if (chr < 0x800) {\r\n            // 2 bytes\r\n            buffer[index++] = 0xC0 | (chr >>> 6);\r\n            buffer[index++] = 0x80 | (chr & 0x3F);\r\n        } else if (chr < 0xD800 || chr > 0xDFFF) {\r\n            // 3 bytes\r\n            buffer[index++] = 0xE0 | (chr >>> 12);\r\n            buffer[index++] = 0x80 | ((chr >>> 6) & 0x3F);\r\n            buffer[index++] = 0x80 | (chr & 0x3F);\r\n        } else {\r\n            // 4 bytes - surrogate pair\r\n            chr = (((chr - 0xD800) << 10) | (string.charCodeAt(idx++) - 0xDC00)) + 0x10000;\r\n            buffer[index++] = 0xF0 | (chr >>> 18);\r\n            buffer[index++] = 0x80 | ((chr >>> 12) & 0x3F);\r\n            buffer[index++] = 0x80 | ((chr >>> 6) & 0x3F);\r\n            buffer[index++] = 0x80 | (chr & 0x3F);\r\n        }\r\n    }\r\n    return buffer.slice(0, index);\r\n}\r\n\r\n/**\r\n * Converts a Uint8Array buffer to a string.\r\n * \r\n * @param buffer - The Uint8Array buffer to convert.\r\n * @returns The converted string.\r\n */\r\nexport function readString(buffer: Uint8Array): string {\r\n    const length = buffer.length;\r\n    if (length > 128) return td.decode(buffer);\r\n    let index = 0;\r\n    const end = length;\r\n    let string = \"\";\r\n    while (index < end) {\r\n        const chunk = [];\r\n        const cEnd = Math.min(index + QUANTUM, end);\r\n        while (index < cEnd) {\r\n            const chr = buffer[index++];\r\n            if (chr < 128) { // 1 byte\r\n                chunk.push(chr);\r\n            } else if ((chr & 0xE0) === 0xC0) { // 2 bytes\r\n                chunk.push((chr & 0x1F) << 6 |\r\n                    (buffer[index++] & 0x3F));\r\n            } else if ((chr & 0xF0) === 0xE0) { // 3 bytes\r\n                chunk.push((chr & 0x0F) << 12 |\r\n                    (buffer[index++] & 0x3F) << 6 |\r\n                    (buffer[index++] & 0x3F));\r\n            } else if ((chr & 0xF8) === 0xF0) { // 4 bytes\r\n                let code = (chr & 0x07) << 18 |\r\n                    (buffer[index++] & 0x3F) << 12 |\r\n                    (buffer[index++] & 0x3F) << 6 |\r\n                    (buffer[index++] & 0x3F);\r\n                if (code < 0x010000) {\r\n                    chunk.push(code);\r\n                } else { // surrogate pair\r\n                    code -= 0x010000;\r\n                    chunk.push((code >>> 10) + 0xD800, (code & 0x3FF) + 0xDC00);\r\n                }\r\n            }\r\n        }\r\n        string += String.fromCharCode(...chunk);\r\n    }\r\n    return string;\r\n}\r\n\r\n\r\n/**\r\n * Converts a base64 string or an array of base64 strings to a regular string.\r\n * @param base64 - The base64 string or an array of base64 strings to convert.\r\n * @returns The converted regular string.\r\n * @note This function is used to convert base64 strings to binary strings. And if failed, it returns the original string.\r\n */\r\nexport function base64ToString(base64: string | string[]): string {\r\n    try {\r\n        if (typeof base64 != \"string\") return base64.map(e => base64ToString(e)).join(\"\");\r\n        const binary_string = atob(base64);\r\n        const len = binary_string.length;\r\n        const bytes = new Uint8Array(len);\r\n        for (let i = 0; i < len; i++) {\r\n            bytes[i] = binary_string.charCodeAt(i);\r\n        }\r\n        return readString(bytes);\r\n    } catch (ex) {\r\n        Logger(\"Base64 To String error\", LOG_LEVEL_VERBOSE);\r\n        Logger(ex, LOG_LEVEL_VERBOSE);\r\n        if (typeof base64 != \"string\") return base64.join(\"\");\r\n        return base64\r\n    }\r\n}\r\n\r\nconst regexpBase64 = /^[A-Za-z0-9+/]+=*$/;\r\n\r\n/**\r\n * Tries to convert a base64 string to an ArrayBuffer.\r\n * \r\n * @param base64 - The base64 string to convert.\r\n * @returns The converted ArrayBuffer if successful, otherwise false.\r\n */\r\nexport function tryConvertBase64ToArrayBuffer(base64: string): ArrayBuffer | false {\r\n    try {\r\n        const b64F = base64.replace(/\\r|\\n/g, \"\");\r\n        if (!regexpBase64.test(b64F)) {\r\n            return false;\r\n        }\r\n\r\n        const binary_string = globalThis.atob(b64F);\r\n        if (globalThis.btoa(binary_string) !== b64F) {\r\n            return false;\r\n        }\r\n        const len = binary_string.length;\r\n        const bytes = new Uint8Array(len);\r\n        for (let i = 0; i < len; i++) {\r\n            bytes[i] = binary_string.charCodeAt(i);\r\n        }\r\n        return bytes.buffer;\r\n    } catch (ex) {\r\n        return false;\r\n    }\r\n}"],"names":[],"mappings":"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"}