{"version":3,"file":"lock_v1.js","sources":["../../src/concurrency/lock_v1.ts"],"sourcesContent":["import { fireAndForget, promiseWithResolver, yieldNextMicrotask } from \"../promises\";\n\ntype Task<T> = () => Promise<T> | T;\ntype Queue<T> = {\n    key: string | symbol,\n    task: Task<T>,\n    resolver: (result: T) => void,\n    rejector: (reason?: any) => void\n    next?: Queue<T>,\n    isRunning?: boolean\n    isFinished?: boolean\n}\n\n\nconst queueTails = new Map<string | symbol, Queue<any> | undefined>();\n\nasync function performTask<T>(queue: Queue<T>) {\n    if (queue.isRunning) {\n        // The same queue has been started\n        return;\n    }\n    try {\n        queue.isRunning = true;\n        const ret = await queue.task();\n        queue.resolver(ret);\n    } catch (ex) {\n        queue.rejector(ex);\n    } finally {\n        const next = queue.next;\n        queue.isFinished = true;\n        // This makes non-sense, we have make the latest queue while enqueuing. \n        if (next) {\n            fireAndForget(async () => { await yieldNextMicrotask(), performTask(next) });\n        } else {\n            queueTails.delete(queue.key);\n        }\n    }\n    return;\n\n}\n\n// --- asynchronous execution / locking utilities\n\ntype QueueOptions = {\n    swapIfExist?: boolean\n    shareResult?: boolean\n}\n\nfunction _enqueue<T>(key: string | symbol, task: Task<T>, { swapIfExist, shareResult }: QueueOptions = {}): Promise<T> {\n    const t = promiseWithResolver<T>();\n    const resolver = t.resolve;\n    const rejector = t.reject;\n\n    const newQueue: Queue<T> = {\n        task,\n        resolver,\n        rejector,\n        key\n    }\n\n    const prev = queueTails.get(key);\n    if (prev === undefined) {\n        queueTails.set(key, newQueue);\n    } else {\n        const current = prev as Queue<T>;\n        queueTails.set(key, newQueue)\n        current.next = newQueue;\n        if (swapIfExist) {\n            // Force cancel previous one\n            current.rejector(new Error(\"Cancelled\"));\n        }\n    }\n    if (!prev || prev.isFinished) {\n        fireAndForget(() => performTask(newQueue));\n    }\n    return t.promise;\n}\n\n/**\n * Run tasks one by one in their group.\n * @param key key of the group\n * @param proc process to run\n * @returns result of the process\n */\nexport function serialized<T>(key: string | symbol, proc: Task<T>): Promise<T> {\n    return _enqueue(key, proc);\n}\n\n/**\n * If free, run task and return the result (Same as serialized).\n * If any process has running, share the result.\n * @param key key of the group\n * @param proc process to run\n */\nexport function shareRunningResult<T>(key: string | symbol, proc: Task<T>): Promise<T> {\n    const current = queueTails.get(key);\n    if (!current) return _enqueue(key, proc);\n    let oldResolver = current.resolver;\n    let oldRejector = current.rejector;\n\n    const resultP = promiseWithResolver<T>();\n\n    // Inject hooked handler\n    current.resolver = (result) => {\n        oldResolver?.(result);\n        resultP.resolve(result);\n    }\n    current.rejector = (result) => {\n        oldRejector?.(result);\n        resultP.reject(result);\n    }\n    resultP.promise.finally(() => {\n        oldResolver = undefined!;\n        oldRejector = undefined!;\n    })\n    return resultP.promise;\n}\n\n/**\n * Skips the execution of a task if it is already duplicated.\n * \n * @param key - The key to identify the task.\n * @param proc - The task to be executed.\n * @returns A promise that resolves to the result of the task, or `null` if the task is duplicated.\n */\nexport function skipIfDuplicated<T>(key: string | symbol, proc: Task<T>): Promise<T | null> {\n    if (queueTails.get(key) !== undefined) return Promise.resolve(null);\n    return _enqueue(key, proc);\n}\n\nconst waitingProcess = new Map<string, () => Promise<any>>();\n\n/**\n * Schedules a process to be executed once if it is not already running.\n * If the process is already running, it will be added to the waiting queue. An existing waiting process will be replaced.\n *\n * @param key - The key used to identify the process.\n * @param proc - The process to be executed.\n * @returns A Promise that resolves once the process has been scheduled.\n */\nexport async function scheduleOnceIfDuplicated<T>(key: string, proc: () => Promise<T>): Promise<void> {\n    if (isLockAcquired(key)) {\n        waitingProcess.set(key, proc);\n        return;\n    }\n    await serialized(key, proc);\n    if (waitingProcess.has(key)) {\n        const nextProc = waitingProcess.get(key);\n        waitingProcess.delete(key);\n        scheduleOnceIfDuplicated(key, nextProc as () => Promise<T>);\n    }\n}\n/**\n * Checks if a lock is acquired for the given key.\n * @param key - The key to check for lock acquisition.\n * @returns `true` if the lock is acquired, `false` otherwise.\n */\nexport function isLockAcquired(key: string): boolean {\n    return queueTails.get(key) !== undefined;\n}\n\n"],"names":[],"mappings":"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"}