{"version":3,"file":"lock.js","sources":["../../src/concurrency/lock.ts"],"sourcesContent":["import { fireAndForget, promiseWithResolver, yieldNextMicrotask } from \"../promises\";\r\n\r\ntype Task<T> = () => Promise<T> | T;\r\ntype Queue<T> = {\r\n    key: string | symbol,\r\n    task: Task<T>,\r\n    resolver: (result: T) => void,\r\n    rejector: (reason?: any) => void\r\n    next?: Queue<T>,\r\n    isRunning?: boolean\r\n    isFinished?: boolean\r\n}\r\n\r\n\r\nconst queueTails = new Map<string | symbol, Queue<any> | undefined>();\r\n\r\nasync function performTask<T>(queue: Queue<T>) {\r\n    if (queue.isRunning) {\r\n        // The same queue has been started\r\n        return;\r\n    }\r\n    try {\r\n        queue.isRunning = true;\r\n        const ret = await queue.task();\r\n        queue.resolver(ret);\r\n    } catch (ex) {\r\n        queue.rejector(ex);\r\n    } finally {\r\n        const next = queue.next;\r\n        queue.isFinished = true;\r\n        // This makes non-sense, we have make the latest queue while enqueuing. \r\n        if (next) {\r\n            fireAndForget(async () => { await yieldNextMicrotask(), performTask(next) });\r\n        } else {\r\n            queueTails.delete(queue.key);\r\n        }\r\n    }\r\n    return;\r\n\r\n}\r\n\r\n// --- asynchronous execution / locking utilities\r\n\r\ntype QueueOptions = {\r\n    swapIfExist?: boolean\r\n    shareResult?: boolean\r\n}\r\n\r\nfunction _enqueue<T>(key: string | symbol, task: Task<T>, { swapIfExist, shareResult }: QueueOptions = {}): Promise<T> {\r\n    const t = promiseWithResolver<T>();\r\n    const resolver = t.resolve;\r\n    const rejector = t.reject;\r\n\r\n    const newQueue: Queue<T> = {\r\n        task,\r\n        resolver,\r\n        rejector,\r\n        key\r\n    }\r\n\r\n    const prev = queueTails.get(key);\r\n    if (prev === undefined) {\r\n        queueTails.set(key, newQueue);\r\n    } else {\r\n        const current = prev as Queue<T>;\r\n        queueTails.set(key, newQueue)\r\n        current.next = newQueue;\r\n        if (swapIfExist) {\r\n            // Force cancel previous one\r\n            current.rejector(new Error(\"Cancelled\"));\r\n        }\r\n    }\r\n    if (!prev || prev.isFinished) {\r\n        fireAndForget(() => performTask(newQueue));\r\n    }\r\n    return t.promise;\r\n}\r\n\r\n/**\r\n * Run tasks one by one in their group.\r\n * @param key key of the group\r\n * @param proc process to run\r\n * @returns result of the process\r\n */\r\nexport function serialized<T>(key: string | symbol, proc: Task<T>): Promise<T> {\r\n    return _enqueue(key, proc);\r\n}\r\n\r\n/**\r\n * If free, run task and return the result (Same as serialized).\r\n * If any process has running, share the result.\r\n * @param key key of the group\r\n * @param proc process to run\r\n */\r\nexport function shareRunningResult<T>(key: string | symbol, proc: Task<T>): Promise<T> {\r\n    const current = queueTails.get(key);\r\n    if (!current) return _enqueue(key, proc);\r\n    let oldResolver = current.resolver;\r\n    let oldRejector = current.rejector;\r\n\r\n    const resultP = promiseWithResolver<T>();\r\n\r\n    // Inject hooked handler\r\n    current.resolver = (result) => {\r\n        oldResolver?.(result);\r\n        resultP.resolve(result);\r\n    }\r\n    current.rejector = (result) => {\r\n        oldRejector?.(result);\r\n        resultP.reject(result);\r\n    }\r\n    resultP.promise.finally(() => {\r\n        oldResolver = undefined!;\r\n        oldRejector = undefined!;\r\n    })\r\n    return resultP.promise;\r\n}\r\n\r\n/**\r\n * Skips the execution of a task if it is already duplicated.\r\n * \r\n * @param key - The key to identify the task.\r\n * @param proc - The task to be executed.\r\n * @returns A promise that resolves to the result of the task, or `null` if the task is duplicated.\r\n */\r\nexport function skipIfDuplicated<T>(key: string | symbol, proc: Task<T>): Promise<T | null> {\r\n    if (queueTails.get(key) !== undefined) return Promise.resolve(null);\r\n    return _enqueue(key, proc);\r\n}\r\n\r\nconst waitingProcess = new Map<string, () => Promise<any>>();\r\n\r\n/**\r\n * Schedules a process to be executed once if it is not already running.\r\n * If the process is already running, it will be added to the waiting queue. An existing waiting process will be replaced.\r\n *\r\n * @param key - The key used to identify the process.\r\n * @param proc - The process to be executed.\r\n * @returns A Promise that resolves once the process has been scheduled.\r\n */\r\nexport async function scheduleOnceIfDuplicated<T>(key: string, proc: () => Promise<T>): Promise<void> {\r\n    if (isLockAcquired(key)) {\r\n        waitingProcess.set(key, proc);\r\n        return;\r\n    }\r\n    await serialized(key, proc);\r\n    if (waitingProcess.has(key)) {\r\n        const nextProc = waitingProcess.get(key);\r\n        waitingProcess.delete(key);\r\n        scheduleOnceIfDuplicated(key, nextProc as () => Promise<T>);\r\n    }\r\n}\r\n/**\r\n * Checks if a lock is acquired for the given key.\r\n * @param key - The key to check for lock acquisition.\r\n * @returns `true` if the lock is acquired, `false` otherwise.\r\n */\r\nexport function isLockAcquired(key: string): boolean {\r\n    return queueTails.get(key) !== undefined;\r\n}\r\n\r\n"],"names":[],"mappings":"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"}