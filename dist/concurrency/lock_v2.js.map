{"version":3,"file":"lock_v2.js","sources":["../../src/concurrency/lock_v2.ts"],"sourcesContent":["// --- asynchronous execution / locking utilities\nimport { fireAndForget, promiseWithResolver } from \"../promises\";\n\ntype Task<T> = () => Promise<T> | T;\n\n/**\n * Run tasks one by one in their group.\n */\nconst serializedMap = new Map<string | symbol, Promise<void>>();\n/**\n * How many tasks waiting for the same key (on serialized processing)\n */\nconst queueCount = new Map<string | symbol, number>();\n\n/**\n * Tasks that are waiting for the same key (on serialized processing)\n */\n\nconst waitingProcessMap = new Map<string | symbol, Task<any>>();\n\n/**\n * Tasks that are waiting for the same key (on sharing result)\n */\nconst shareSerializedMap = new Map<string | symbol, Promise<any>>();\n\n/**\n * Tasks that are waiting for the same key (on skipping duplicated)\n */\nconst skipDuplicatedMap = new Map<string | symbol, Promise<any>>();\n\n/**\n * Run tasks one by one in their group.\n * @param key key of the group\n * @param proc process to run\n * @returns result of the process\n */\n\nexport function serialized<T>(key: string | symbol, proc: Task<T>): Promise<T> {\n    const prev = serializedMap.get(key);\n    const p = promiseWithResolver<T>();\n    queueCount.set(key, (queueCount.get(key) ?? 0) + 1);\n    const nextTask = async () => {\n        try {\n            p.resolve(await proc());\n        } catch (ex) {\n            p.reject(ex);\n        } finally {\n            const count = queueCount.get(key)! - 1;\n            if (count === 0) {\n                serializedMap.delete(key);\n                queueCount.delete(key);\n            } else {\n                queueCount.set(key, count);\n            }\n        }\n    };\n    if (prev) {\n        const newP = prev.then(() => nextTask());\n        serializedMap.set(key, newP);\n    } else {\n        serializedMap.set(key, nextTask());\n    }\n    return p.promise;\n}\n\n\n/**\n * If free, run task and return the result (Same as serialized).\n * If any process has running, share the result.\n * Mostly same as `SlipBoard.issueAndProceed` but this is for general purpose.\n * @param key key of the group\n * @param proc process to run\n */\nexport function shareRunningResult<T>(key: string | symbol, proc: Task<T>): Promise<T> {\n    const prev = shareSerializedMap.get(key) as Promise<T> | undefined;\n    if (prev) return prev;\n\n    const p = promiseWithResolver<T>();\n    shareSerializedMap.set(key, p.promise);\n\n    const task = async () => {\n        try {\n            p.resolve(await proc());\n        } catch (ex) {\n            p.reject(ex);\n        } finally {\n            shareSerializedMap.delete(key);\n        }\n    };\n    fireAndForget(() => task());\n    return p.promise;\n}\n\n\n/**\n * Skips the execution of a task if it is already duplicated.\n * \n * @param key - The key to identify the task.\n * @param proc - The task to be executed.\n * @returns A promise that resolves to the result of the task, or `null` if the task is duplicated.\n */\nexport function skipIfDuplicated<T>(key: string | symbol, proc: Task<T>): Promise<T | null> {\n    const prev = skipDuplicatedMap.get(key) as Promise<T> | undefined;\n    if (prev) return Promise.resolve(null);\n\n    const p = promiseWithResolver<T>();\n    skipDuplicatedMap.set(key, p.promise);\n\n    const task = async () => {\n        try {\n            p.resolve(await proc());\n        } catch (ex) {\n            p.reject(ex);\n        } finally {\n            skipDuplicatedMap.delete(key);\n        }\n    };\n    fireAndForget(() => task());\n    return p.promise;\n}\n\n/**\n * Schedules a process to be executed once if it is not already running.\n * If the process is already running, it will be added to the waiting queue. An existing waiting process will be replaced.\n *\n * @param key - The key used to identify the process.\n * @param proc - The process to be executed.\n * @returns A Promise that resolves once the process has been scheduled.\n */\nexport async function scheduleOnceIfDuplicated<T>(key: string, proc: () => Promise<T>): Promise<T | null | undefined> {\n\n    if (isLockAcquired(key)) {\n        waitingProcessMap.set(key, proc);\n        return Promise.resolve(undefined);\n    } else {\n        return await serialized(key, proc).then(() => {\n            const nextProc = waitingProcessMap.get(key);\n            if (nextProc) {\n                waitingProcessMap.delete(key);\n                return scheduleOnceIfDuplicated(key, nextProc);\n            }\n        });\n    }\n}\n\n/**\n * Checks if a serialised-processing-lock is acquired for the given key.\n * @param key - The key to check for lock acquisition.\n * @returns `true` if the lock is acquired, `false` otherwise.\n */\nexport function isLockAcquired(key: string | symbol): boolean {\n    const count = queueCount.get(key) ?? 0;\n    return count > 0;\n}\n"],"names":[],"mappings":"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"}