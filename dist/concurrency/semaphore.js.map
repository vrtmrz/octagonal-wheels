{"version":3,"file":"semaphore.js","sources":["../../src/concurrency/semaphore.ts"],"sourcesContent":["\nfunction makeUniqueString() {\n    const randomStrSrc = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    const temp = [...Array(30)]\n        .map(() => Math.floor(Math.random() * randomStrSrc.length))\n        .map((e) => randomStrSrc[e])\n        .join(\"\");\n    return `${Date.now()}-${temp}`;\n}\n\nexport type QueueNotifier = {\n    key: string;\n    notify: (result: boolean) => void;\n    semaphoreStopper: Promise<SemaphoreReleaser | false>;\n    quantity: number;\n    memo?: string;\n    state: \"NONE\" | \"RUNNING\" | \"DONE\";\n    timer?: ReturnType<typeof setTimeout>;\n}\nexport type SemaphoreReleaser = () => void;\n\nexport type SemaphoreObject = {\n    _acquire(quantity: number, memo: string, timeout: number): Promise<SemaphoreReleaser | false>;\n    acquire(quantity?: number, memo?: string): Promise<SemaphoreReleaser>;\n    tryAcquire(quantity?: number, timeout?: number, memo?: string): Promise<SemaphoreReleaser | false>;\n    peekQueues(): QueueNotifier[];\n    setLimit(limit: number): void;\n\n}\n/**\n * Semaphore handling lib.\n * @param limit Maximum number that can be acquired.\n * @returns Instance of SemaphoreObject\n */\nexport function Semaphore(limit: number, onRelease?: (currentQueue: QueueNotifier[]) => Promise<void> | void): SemaphoreObject {\n    let _limit = limit;\n\n    let currentProcesses = 0;\n    let queue: QueueNotifier[] = [];\n    /**\n     * Semaphore processing pump\n     */\n    function execProcess() {\n        //Delete already finished \n        queue = queue.filter(e => e.state != \"DONE\");\n\n        // acquiring semaphore by order\n        for (const queueItem of queue) {\n            if (queueItem.state != \"NONE\") continue;\n            if (queueItem.quantity + currentProcesses > _limit) {\n                break;\n            }\n            queueItem.state = \"RUNNING\";\n            currentProcesses += queueItem.quantity;\n            if (queueItem?.timer) {\n                clearTimeout(queueItem.timer);\n            }\n            queueItem.notify(true);\n        }\n    }\n\n    /**\n     * Mark DONE.\n     * @param key \n     */\n    function release(key: string) {\n        const finishedTask = queue.find(e => e.key == key);\n        if (!finishedTask) {\n            throw new Error(\"Missing locked semaphore!\");\n        }\n\n        if (finishedTask.state == \"RUNNING\") {\n            currentProcesses -= finishedTask.quantity;\n        }\n        finishedTask.state = \"DONE\";\n        if (onRelease) onRelease(queue.filter(e => e.state != \"DONE\"));\n        execProcess();\n    }\n    return {\n        setLimit(limit) {\n            _limit = limit;\n        },\n        _acquire(quantity: number, memo: string, timeout: number): Promise<SemaphoreReleaser | false> {\n            const key = makeUniqueString();\n            if (_limit < quantity) {\n                throw Error(\"Too big quantity\");\n            }\n\n            // function for notify\n            // When we call this function, semaphore acquired by resolving promise.\n            // (Or, notify acquiring is timed out.)\n            let notify = (_: boolean) => { };\n            const semaphoreStopper = new Promise<SemaphoreReleaser | false>(res => {\n                notify = (result: boolean) => {\n                    if (result) {\n                        res(() => { release(key) })\n                    } else {\n                        res(false);\n                    }\n                }\n            })\n            const notifier: QueueNotifier = {\n                key,\n                notify,\n                semaphoreStopper,\n                quantity,\n                memo,\n                state: \"NONE\"\n            }\n            if (timeout) notifier.timer = setTimeout(() => {\n                // If acquiring is timed out, clear queue and notify failed.\n                release(key);\n                notify(false);\n            }, timeout)\n\n            // Push into the queue once.\n            queue.push(notifier);\n\n            //Execute loop\n            execProcess();\n\n            //returning Promise\n            return semaphoreStopper;\n        },\n        acquire(quantity = 1, memo?: string): Promise<SemaphoreReleaser> {\n            return this._acquire(quantity, memo ?? \"\", 0) as Promise<SemaphoreReleaser>;\n        },\n        tryAcquire(quantity = 1, timeout = 1, memo?: string,): Promise<SemaphoreReleaser | false> {\n            return this._acquire(quantity, memo ?? \"\", timeout)\n        },\n        peekQueues() {\n            return queue;\n        }\n    }\n}\n"],"names":[],"mappings":"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"}