{"version":3,"file":"semaphore.js","sources":["../../src/concurrency/semaphore.ts"],"sourcesContent":["\r\nfunction makeUniqueString() {\r\n    const randomStrSrc = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n    const temp = [...Array(30)]\r\n        .map(() => Math.floor(Math.random() * randomStrSrc.length))\r\n        .map((e) => randomStrSrc[e])\r\n        .join(\"\");\r\n    return `${Date.now()}-${temp}`;\r\n}\r\n\r\nexport type QueueNotifier = {\r\n    key: string;\r\n    notify: (result: boolean) => void;\r\n    semaphoreStopper: Promise<SemaphoreReleaser | false>;\r\n    quantity: number;\r\n    memo?: string;\r\n    state: \"NONE\" | \"RUNNING\" | \"DONE\";\r\n    timer?: ReturnType<typeof setTimeout>;\r\n}\r\nexport type SemaphoreReleaser = () => void;\r\n\r\nexport type SemaphoreObject = {\r\n    _acquire(quantity: number, memo: string, timeout: number): Promise<SemaphoreReleaser | false>;\r\n    acquire(quantity?: number, memo?: string): Promise<SemaphoreReleaser>;\r\n    tryAcquire(quantity?: number, timeout?: number, memo?: string): Promise<SemaphoreReleaser | false>;\r\n    peekQueues(): QueueNotifier[];\r\n    setLimit(limit: number): void;\r\n\r\n}\r\n/**\r\n * Semaphore handling lib.\r\n * @param limit Maximum number that can be acquired.\r\n * @returns Instance of SemaphoreObject\r\n */\r\nexport function Semaphore(limit: number, onRelease?: (currentQueue: QueueNotifier[]) => Promise<void> | void): SemaphoreObject {\r\n    let _limit = limit;\r\n\r\n    let currentProcesses = 0;\r\n    let queue: QueueNotifier[] = [];\r\n    /**\r\n     * Semaphore processing pump\r\n     */\r\n    function execProcess() {\r\n        //Delete already finished \r\n        queue = queue.filter(e => e.state != \"DONE\");\r\n\r\n        // acquiring semaphore by order\r\n        for (const queueItem of queue) {\r\n            if (queueItem.state != \"NONE\") continue;\r\n            if (queueItem.quantity + currentProcesses > _limit) {\r\n                break;\r\n            }\r\n            queueItem.state = \"RUNNING\";\r\n            currentProcesses += queueItem.quantity;\r\n            if (queueItem?.timer) {\r\n                clearTimeout(queueItem.timer);\r\n            }\r\n            queueItem.notify(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Mark DONE.\r\n     * @param key \r\n     */\r\n    function release(key: string) {\r\n        const finishedTask = queue.find(e => e.key == key);\r\n        if (!finishedTask) {\r\n            throw new Error(\"Missing locked semaphore!\");\r\n        }\r\n\r\n        if (finishedTask.state == \"RUNNING\") {\r\n            currentProcesses -= finishedTask.quantity;\r\n        }\r\n        finishedTask.state = \"DONE\";\r\n        if (onRelease) onRelease(queue.filter(e => e.state != \"DONE\"));\r\n        execProcess();\r\n    }\r\n    return {\r\n        setLimit(limit) {\r\n            _limit = limit;\r\n        },\r\n        _acquire(quantity: number, memo: string, timeout: number): Promise<SemaphoreReleaser | false> {\r\n            const key = makeUniqueString();\r\n            if (_limit < quantity) {\r\n                throw Error(\"Too big quantity\");\r\n            }\r\n\r\n            // function for notify\r\n            // When we call this function, semaphore acquired by resolving promise.\r\n            // (Or, notify acquiring is timed out.)\r\n            let notify = (_: boolean) => { };\r\n            const semaphoreStopper = new Promise<SemaphoreReleaser | false>(res => {\r\n                notify = (result: boolean) => {\r\n                    if (result) {\r\n                        res(() => { release(key) })\r\n                    } else {\r\n                        res(false);\r\n                    }\r\n                }\r\n            })\r\n            const notifier: QueueNotifier = {\r\n                key,\r\n                notify,\r\n                semaphoreStopper,\r\n                quantity,\r\n                memo,\r\n                state: \"NONE\"\r\n            }\r\n            if (timeout) notifier.timer = setTimeout(() => {\r\n                // If acquiring is timed out, clear queue and notify failed.\r\n                release(key);\r\n                notify(false);\r\n            }, timeout)\r\n\r\n            // Push into the queue once.\r\n            queue.push(notifier);\r\n\r\n            //Execute loop\r\n            execProcess();\r\n\r\n            //returning Promise\r\n            return semaphoreStopper;\r\n        },\r\n        acquire(quantity = 1, memo?: string): Promise<SemaphoreReleaser> {\r\n            return this._acquire(quantity, memo ?? \"\", 0) as Promise<SemaphoreReleaser>;\r\n        },\r\n        tryAcquire(quantity = 1, timeout = 1, memo?: string,): Promise<SemaphoreReleaser | false> {\r\n            return this._acquire(quantity, memo ?? \"\", timeout)\r\n        },\r\n        peekQueues() {\r\n            return queue;\r\n        }\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}