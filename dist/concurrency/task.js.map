{"version":3,"file":"task.js","sources":["../../src/concurrency/task.ts"],"sourcesContent":["import { promiseWithResolver } from \"../promises\";\r\nexport type TaskProcessing<T> = Promise<T>;\r\nexport type TaskWaiting<T> = () => Promise<T>;\r\nexport type Task<T> = TaskProcessing<T> | TaskWaiting<T>;\r\n\r\nexport type TaskResult<T, U extends Error> = { ok: T } | { err: U };\r\n\r\nexport type TaskResultWithKey<T, U extends Error> = TaskResult<T, U> & { key: number };\r\n\r\nexport type ProcessingTaskResultWithKey<T, U extends Error> = Promise<TaskResultWithKey<T, U>>;\r\n\r\nexport function unwrapTaskResult<T, U extends Error>(result: TaskResult<T, U>): T | U {\r\n    if (\"ok\" in result) return result.ok;\r\n    if (\"err\" in result) return result.err;\r\n    throw new Error(\"Argument Exception: Could not unwrap\");\r\n}\r\nfunction isTaskWaiting<T>(task: Task<T>): task is TaskWaiting<T> {\r\n    if (task instanceof Promise) {\r\n        return false;\r\n    }\r\n    if (task instanceof Function) {\r\n        return true;\r\n    }\r\n    throw new Error(\"Invalid state\");\r\n\r\n}\r\n\r\nasync function wrapEachProcess<T>(key: number, task: TaskProcessing<T>) {\r\n    try {\r\n        const r = await task;\r\n        return { key, ok: r };\r\n    } catch (ex) {\r\n        return { key, err: ex instanceof Error ? ex : new Error(`${ex}`) }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Perform all tasks within given concurrency.\r\n * @param limit Concurrency limit\r\n * @param tasks Tasks to perform all\r\n * \r\n */\r\nexport async function* processAllGeneratorTasksWithConcurrencyLimit<T>(limit: number, tasks: AsyncGenerator<Task<T>, undefined, unknown>): AsyncGenerator<TaskResultWithKey<T, Error>, void, unknown> {\r\n    const nowProcessing = new Map<number, ProcessingTaskResultWithKey<T, Error>>();\r\n    let idx = 0;\r\n\r\n    // for await (const task of tasks){\r\n\r\n    let generatorDone = false;\r\n    while (nowProcessing.size > 0 || !generatorDone) {\r\n        L2:\r\n        while (nowProcessing.size < limit && !generatorDone) {\r\n            const w = await tasks.next();\r\n            if (w.done) {\r\n                generatorDone = true;\r\n                // break L2;\r\n            }\r\n            if (w.value === undefined) {\r\n                break L2;\r\n            }\r\n            const task = w.value;\r\n            idx++;\r\n            const newProcess = isTaskWaiting(task) ? task() : task;\r\n            const wrappedPromise = wrapEachProcess(idx, newProcess);\r\n            nowProcessing.set(idx, wrappedPromise);\r\n        }\r\n        const done = await Promise.race(nowProcessing.values());\r\n        nowProcessing.delete(done.key);\r\n        yield done;\r\n    }\r\n}\r\n\r\nexport async function* pipeGeneratorToGenerator<T, U>(generator: AsyncGenerator<T>, callback: (obj: T) => Promise<U>): AsyncGenerator<TaskWaiting<U>> {\r\n    for await (const e of generator) {\r\n        const closure = () => callback(e);\r\n        yield closure;\r\n    }\r\n}\r\nexport async function* pipeArrayToGenerator<T, U>(array: T[], callback: (obj: T) => Promise<U>): AsyncGenerator<TaskWaiting<U>> {\r\n    for (const e of array) {\r\n        const closure = () => callback(e);\r\n        yield closure;\r\n    }\r\n}\r\n\r\n/**\r\n * Perform all tasks within given concurrency.\r\n * @param limit Concurrency limit\r\n * @param tasks Tasks to perform all\r\n * \r\n */\r\nexport async function* processAllTasksWithConcurrencyLimit<T>(limit: number, tasks: Task<T>[]): AsyncGenerator<TaskResultWithKey<T, Error>, void, unknown> {\r\n    const nowProcessing = new Map<number, ProcessingTaskResultWithKey<T, Error>>();\r\n    let idx = 0;\r\n    const pendingTasks = tasks.reverse();\r\n\r\n    while (pendingTasks.length > 0 || nowProcessing.size > 0) {\r\n        L2:\r\n        while (nowProcessing.size < limit && pendingTasks.length > 0) {\r\n            const task = pendingTasks.pop(); // Pop is faster than shift.\r\n            if (task === undefined) {\r\n                break L2;\r\n            }\r\n            idx++;\r\n            const newProcess = isTaskWaiting(task) ? task() : task;\r\n            const wrappedPromise = wrapEachProcess(idx, newProcess);\r\n            nowProcessing.set(idx, wrappedPromise);\r\n        }\r\n        const done = await Promise.race(nowProcessing.values());\r\n        nowProcessing.delete(done.key);\r\n        yield done;\r\n    }\r\n}\r\n\r\n/**\r\n * Perform all tasks and returns all result by keeping the order.\r\n * @param limit Concurrency limit\r\n * @param tasks Tasks to perform all\r\n * @returns \r\n */\r\nexport async function mapAllTasksWithConcurrencyLimit<T>(limit: number, tasks: Task<T>[]): Promise<TaskResultWithKey<T, Error>[]> {\r\n    const results = new Map<number, TaskResultWithKey<T, Error>>();\r\n    for await (const v of processAllTasksWithConcurrencyLimit(limit, tasks)) {\r\n        results.set(v.key, v);\r\n    }\r\n    const ret = [...results.entries()].sort((a, b) => a[0] - b[0]).map(e => e[1]);\r\n    return ret;\r\n}\r\n\r\n\r\nconst tasks: { [key: string]: ReturnType<typeof setTimeout> } = {};\r\nexport function scheduleTask(key: string, timeout: number, proc: (() => Promise<any> | void), skipIfTaskExist?: boolean) {\r\n    if (skipIfTaskExist && key in tasks) {\r\n        return;\r\n    }\r\n    cancelTask(key);\r\n    tasks[key] = setTimeout(async () => {\r\n        delete tasks[key];\r\n        await proc();\r\n    }, timeout);\r\n}\r\nexport function cancelTask(key: string) {\r\n    if (key in tasks) {\r\n        clearTimeout(tasks[key]);\r\n        delete tasks[key];\r\n    }\r\n}\r\nexport function cancelAllTasks() {\r\n    for (const v in tasks) {\r\n        clearTimeout(tasks[v]);\r\n        delete tasks[v];\r\n    }\r\n}\r\nconst intervals: { [key: string]: ReturnType<typeof setInterval> } = {};\r\nexport function setPeriodicTask(key: string, timeout: number, proc: (() => Promise<any> | void)) {\r\n    cancelPeriodicTask(key);\r\n    intervals[key] = setInterval(async () => {\r\n        delete intervals[key];\r\n        await proc();\r\n    }, timeout);\r\n}\r\nexport function cancelPeriodicTask(key: string) {\r\n    if (key in intervals) {\r\n        clearInterval(intervals[key]);\r\n        delete intervals[key];\r\n    }\r\n}\r\nexport function cancelAllPeriodicTask() {\r\n    for (const v in intervals) {\r\n        clearInterval(intervals[v]);\r\n        delete intervals[v];\r\n    }\r\n}\r\n\r\n\r\ntype WaitingItem = {\r\n    waitFrom: number,\r\n    timeout: number,\r\n    timeoutPromise: ReturnType<typeof promiseWithResolver<boolean>>;\r\n    timer: ReturnType<typeof setTimeout>\r\n}\r\nconst waitingItems = new Map<string, WaitingItem>();\r\n\r\nexport function waitForTimeout(key: string, timeout: number): Promise<boolean> {\r\n    if (waitingItems.has(key)) {\r\n        return waitingItems.get(key)!.timeoutPromise.promise;\r\n    }\r\n    const timeoutPromise = promiseWithResolver<boolean>();\r\n    const timer = setTimeout(() => {\r\n        finishWaitingForTimeout(key, true);\r\n    }, timeout);\r\n    waitingItems.set(key, {\r\n        waitFrom: Date.now(),\r\n        timeout,\r\n        timeoutPromise: timeoutPromise,\r\n        timer\r\n    });\r\n    return timeoutPromise.promise\r\n}\r\nexport function finishWaitingForTimeout(key: string, hasTimeout: boolean = false): boolean {\r\n    const x = waitingItems.get(key);\r\n    if (x) {\r\n        if (x.timer) clearTimeout(x.timer);\r\n        x.timeoutPromise.resolve(hasTimeout);\r\n        waitingItems.delete(key);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexport function finishAllWaitingForTimeout(prefix: string, hasTimeout: boolean): void {\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    for (const [key, _] of waitingItems) {\r\n        if (key.startsWith(prefix)) {\r\n            finishWaitingForTimeout(key, hasTimeout);\r\n        }\r\n    }\r\n}\r\n\r\nexport function isWaitingForTimeout(key: string): boolean {\r\n    return waitingItems.has(key);\r\n}"],"names":[],"mappings":"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"}