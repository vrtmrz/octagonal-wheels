{"version":3,"file":"task.js","sources":["../../src/concurrency/task.ts"],"sourcesContent":["import { promiseWithResolver } from \"../promises\";\nexport type TaskProcessing<T> = Promise<T>;\nexport type TaskWaiting<T> = () => Promise<T>;\nexport type Task<T> = TaskProcessing<T> | TaskWaiting<T>;\n\nexport type TaskResult<T, U extends Error> = { ok: T } | { err: U };\n\nexport type TaskResultWithKey<T, U extends Error> = TaskResult<T, U> & { key: number };\n\nexport type ProcessingTaskResultWithKey<T, U extends Error> = Promise<TaskResultWithKey<T, U>>;\n\nexport function unwrapTaskResult<T, U extends Error>(result: TaskResult<T, U>): T | U {\n    if (\"ok\" in result) return result.ok;\n    if (\"err\" in result) return result.err;\n    throw new Error(\"Argument Exception: Could not unwrap\");\n}\nfunction isTaskWaiting<T>(task: Task<T>): task is TaskWaiting<T> {\n    if (task instanceof Promise) {\n        return false;\n    }\n    if (task instanceof Function) {\n        return true;\n    }\n    throw new Error(\"Invalid state\");\n\n}\n\nasync function wrapEachProcess<T>(key: number, task: TaskProcessing<T>) {\n    try {\n        const r = await task;\n        return { key, ok: r };\n    } catch (ex) {\n        return { key, err: ex instanceof Error ? ex : new Error(`${ex}`) }\n    }\n}\n\n\n/**\n * Perform all tasks within given concurrency.\n * @param limit Concurrency limit\n * @param tasks Tasks to perform all\n * \n */\nexport async function* processAllGeneratorTasksWithConcurrencyLimit<T>(limit: number, tasks: AsyncGenerator<Task<T>, undefined, unknown>): AsyncGenerator<TaskResultWithKey<T, Error>, void, unknown> {\n    const nowProcessing = new Map<number, ProcessingTaskResultWithKey<T, Error>>();\n    let idx = 0;\n\n    // for await (const task of tasks){\n\n    let generatorDone = false;\n    while (nowProcessing.size > 0 || !generatorDone) {\n        L2:\n        while (nowProcessing.size < limit && !generatorDone) {\n            const w = await tasks.next();\n            if (w.done) {\n                generatorDone = true;\n                // break L2;\n            }\n            if (w.value === undefined) {\n                break L2;\n            }\n            const task = w.value;\n            idx++;\n            const newProcess = isTaskWaiting(task) ? task() : task;\n            const wrappedPromise = wrapEachProcess(idx, newProcess);\n            nowProcessing.set(idx, wrappedPromise);\n        }\n        const done = await Promise.race(nowProcessing.values());\n        nowProcessing.delete(done.key);\n        yield done;\n    }\n}\n\nexport async function* pipeGeneratorToGenerator<T, U>(generator: AsyncGenerator<T>, callback: (obj: T) => Promise<U>): AsyncGenerator<TaskWaiting<U>> {\n    for await (const e of generator) {\n        const closure = () => callback(e);\n        yield closure;\n    }\n}\nexport async function* pipeArrayToGenerator<T, U>(array: T[], callback: (obj: T) => Promise<U>): AsyncGenerator<TaskWaiting<U>> {\n    for (const e of array) {\n        const closure = () => callback(e);\n        yield closure;\n    }\n}\n\n/**\n * Perform all tasks within given concurrency.\n * @param limit Concurrency limit\n * @param tasks Tasks to perform all\n * \n */\nexport async function* processAllTasksWithConcurrencyLimit<T>(limit: number, tasks: Task<T>[]): AsyncGenerator<TaskResultWithKey<T, Error>, void, unknown> {\n    const nowProcessing = new Map<number, ProcessingTaskResultWithKey<T, Error>>();\n    let idx = 0;\n    const pendingTasks = tasks.reverse();\n\n    while (pendingTasks.length > 0 || nowProcessing.size > 0) {\n        L2:\n        while (nowProcessing.size < limit && pendingTasks.length > 0) {\n            const task = pendingTasks.pop(); // Pop is faster than shift.\n            if (task === undefined) {\n                break L2;\n            }\n            idx++;\n            const newProcess = isTaskWaiting(task) ? task() : task;\n            const wrappedPromise = wrapEachProcess(idx, newProcess);\n            nowProcessing.set(idx, wrappedPromise);\n        }\n        const done = await Promise.race(nowProcessing.values());\n        nowProcessing.delete(done.key);\n        yield done;\n    }\n}\n\n/**\n * Perform all tasks and returns all result by keeping the order.\n * @param limit Concurrency limit\n * @param tasks Tasks to perform all\n * @returns \n */\nexport async function mapAllTasksWithConcurrencyLimit<T>(limit: number, tasks: Task<T>[]): Promise<TaskResultWithKey<T, Error>[]> {\n    const results = new Map<number, TaskResultWithKey<T, Error>>();\n    for await (const v of processAllTasksWithConcurrencyLimit(limit, tasks)) {\n        results.set(v.key, v);\n    }\n    const ret = [...results.entries()].sort((a, b) => a[0] - b[0]).map(e => e[1]);\n    return ret;\n}\n\n\nconst tasks: { [key: string]: ReturnType<typeof setTimeout> } = {};\nexport function scheduleTask(key: string, timeout: number, proc: (() => Promise<any> | void), skipIfTaskExist?: boolean) {\n    if (skipIfTaskExist && key in tasks) {\n        return;\n    }\n    cancelTask(key);\n    tasks[key] = setTimeout(async () => {\n        delete tasks[key];\n        await proc();\n    }, timeout);\n}\nexport function cancelTask(key: string) {\n    if (key in tasks) {\n        clearTimeout(tasks[key]);\n        delete tasks[key];\n    }\n}\nexport function cancelAllTasks() {\n    for (const v in tasks) {\n        clearTimeout(tasks[v]);\n        delete tasks[v];\n    }\n}\nconst intervals: { [key: string]: ReturnType<typeof setInterval> } = {};\nexport function setPeriodicTask(key: string, timeout: number, proc: (() => Promise<any> | void)) {\n    cancelPeriodicTask(key);\n    intervals[key] = setInterval(async () => {\n        delete intervals[key];\n        await proc();\n    }, timeout);\n}\nexport function cancelPeriodicTask(key: string) {\n    if (key in intervals) {\n        clearInterval(intervals[key]);\n        delete intervals[key];\n    }\n}\nexport function cancelAllPeriodicTask() {\n    for (const v in intervals) {\n        clearInterval(intervals[v]);\n        delete intervals[v];\n    }\n}\n\n\ntype WaitingItem = {\n    waitFrom: number,\n    timeout: number,\n    timeoutPromise: ReturnType<typeof promiseWithResolver<boolean>>;\n    timer: ReturnType<typeof setTimeout>\n}\nconst waitingItems = new Map<string, WaitingItem>();\n\nexport function waitForTimeout(key: string, timeout: number): Promise<boolean> {\n    if (waitingItems.has(key)) {\n        return waitingItems.get(key)!.timeoutPromise.promise;\n    }\n    const timeoutPromise = promiseWithResolver<boolean>();\n    const timer = setTimeout(() => {\n        finishWaitingForTimeout(key, true);\n    }, timeout);\n    waitingItems.set(key, {\n        waitFrom: Date.now(),\n        timeout,\n        timeoutPromise: timeoutPromise,\n        timer\n    });\n    return timeoutPromise.promise\n}\nexport function finishWaitingForTimeout(key: string, hasTimeout: boolean = false): boolean {\n    const x = waitingItems.get(key);\n    if (x) {\n        if (x.timer) clearTimeout(x.timer);\n        x.timeoutPromise.resolve(hasTimeout);\n        waitingItems.delete(key);\n        return true;\n    }\n    return false;\n}\nexport function finishAllWaitingForTimeout(prefix: string, hasTimeout: boolean): void {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const [key, _] of waitingItems) {\n        if (key.startsWith(prefix)) {\n            finishWaitingForTimeout(key, hasTimeout);\n        }\n    }\n}\n\nexport function isWaitingForTimeout(key: string): boolean {\n    return waitingItems.has(key);\n}"],"names":[],"mappings":"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"}