{"version":3,"file":"semaphore_v2.js","sources":["../../src/concurrency/semaphore_v2.ts"],"sourcesContent":["import { cancelableDelay, TIMED_OUT_SIGNAL, fireAndForget, promiseWithResolver, yieldMicrotask } from \"../promises\";\nexport type SemaphoreReleaser = () => void;\nexport type SemaphoreObject = {\n    acquire(quantity?: number): Promise<SemaphoreReleaser>;\n    tryAcquire(quantity?: number, timeout?: number): Promise<SemaphoreReleaser | false>;\n    // setLimit(limit: number): void;\n    waiting: number;\n};\nexport function Semaphore(limit: number): SemaphoreObject {\n    let counter = 0;\n    const _limit = limit;\n\n    const queue: PromiseWithResolvers<void>[] = [];\n    const semaphore = {\n        get waiting() {\n            return queue.length;\n        },\n        async tryAcquire(quantity: number = 1, timeout: number) {\n\n            if (counter < _limit) {\n                counter += quantity;\n                return () => {\n                    this.release(quantity);\n                };\n            }\n            const d = cancelableDelay(timeout, TIMED_OUT_SIGNAL);\n            const aq = this.acquire(quantity);\n            const p = await Promise.race([\n                d.promise,\n                aq,\n            ]);\n            if (p === TIMED_OUT_SIGNAL) {\n                // Cancel after acquired\n                fireAndForget(() => aq.then(release => release()));\n                return false;\n            }\n            return p;\n        },\n        async acquire(quantity: number = 1): Promise<() => void> {\n            if (counter < _limit) {\n                counter += quantity;\n                return () => this.release();\n            }\n            const n = promiseWithResolver<void>();\n            queue.push(n);\n            await n.promise;\n            return () => {\n                this.release(quantity);\n            };\n\n\n        },\n        release(quantity: number = 1) {\n            if (queue.length > 0) {\n                const next = queue.shift();\n                if (next) {\n                    fireAndForget(async () => await yieldMicrotask().then(() => next.resolve()));\n                }\n            } else {\n                if (counter > 0) {\n                    counter -= quantity;\n                }\n            }\n        }\n    };\n    return semaphore as SemaphoreObject;\n}"],"names":[],"mappings":";;AAQM,SAAU,SAAS,CAAC,KAAa,EAAA;IACnC,IAAI,OAAO,GAAG,CAAC;IACf,MAAM,MAAM,GAAG,KAAK;IAEpB,MAAM,KAAK,GAAiC,EAAE;AAC9C,IAAA,MAAM,SAAS,GAAG;AACd,QAAA,IAAI,OAAO,GAAA;YACP,OAAO,KAAK,CAAC,MAAM;SACtB;AACD,QAAA,MAAM,UAAU,CAAC,QAAmB,GAAA,CAAC,EAAE,OAAe,EAAA;AAElD,YAAA,IAAI,OAAO,GAAG,MAAM,EAAE;gBAClB,OAAO,IAAI,QAAQ;AACnB,gBAAA,OAAO,MAAK;AACR,oBAAA,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC;AAC1B,iBAAC;;YAEL,MAAM,CAAC,GAAG,eAAe,CAAC,OAAO,EAAE,gBAAgB,CAAC;YACpD,MAAM,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC;AACjC,YAAA,MAAM,CAAC,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC;AACzB,gBAAA,CAAC,CAAC,OAAO;gBACT,EAAE;AACL,aAAA,CAAC;AACF,YAAA,IAAI,CAAC,KAAK,gBAAgB,EAAE;;AAExB,gBAAA,aAAa,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,OAAO,IAAI,OAAO,EAAE,CAAC,CAAC;AAClD,gBAAA,OAAO,KAAK;;AAEhB,YAAA,OAAO,CAAC;SACX;AACD,QAAA,MAAM,OAAO,CAAC,QAAA,GAAmB,CAAC,EAAA;AAC9B,YAAA,IAAI,OAAO,GAAG,MAAM,EAAE;gBAClB,OAAO,IAAI,QAAQ;AACnB,gBAAA,OAAO,MAAM,IAAI,CAAC,OAAO,EAAE;;AAE/B,YAAA,MAAM,CAAC,GAAG,mBAAmB,EAAQ;AACrC,YAAA,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;YACb,MAAM,CAAC,CAAC,OAAO;AACf,YAAA,OAAO,MAAK;AACR,gBAAA,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC;AAC1B,aAAC;SAGJ;QACD,OAAO,CAAC,WAAmB,CAAC,EAAA;AACxB,YAAA,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;AAClB,gBAAA,MAAM,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE;gBAC1B,IAAI,IAAI,EAAE;oBACN,aAAa,CAAC,YAAY,MAAM,cAAc,EAAE,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;;;iBAE7E;AACH,gBAAA,IAAI,OAAO,GAAG,CAAC,EAAE;oBACb,OAAO,IAAI,QAAQ;;;;KAIlC;AACD,IAAA,OAAO,SAA4B;AACvC;;;;"}