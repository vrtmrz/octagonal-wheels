{"version":3,"file":"xxhash.js","sources":["../../src/hash/xxhash.ts"],"sourcesContent":["import { default as xxhashOld, type Exports } from \"xxhash-wasm\";\r\n//@ts-ignore\r\nimport { default as xxhashNew } from \"../patched_xxhash_wasm/xxhash-wasm.js\";\r\nimport type { XXHashAPI } from \"xxhash-wasm-102\";\r\nimport { Logger, LOG_LEVEL_VERBOSE } from \"../common/logger.js\";\r\nimport { writeString, arrayBufferToBase64Single } from \"../binary\";\r\n\r\nexport { xxhashOld, xxhashNew }\r\n\r\nlet hashFunc: (input: string, seed?: number) => string;\r\n\r\nasync function initHashFunc() {\r\n    try {\r\n        const { h32ToString } = await (xxhashNew as unknown as () => Promise<XXHashAPI>)();\r\n        hashFunc = h32ToString;\r\n        Logger(`xxhash for plugin initialised`, LOG_LEVEL_VERBOSE);\r\n    } catch (ex) {\r\n        Logger(`Could not initialise xxhash. fallback...`, LOG_LEVEL_VERBOSE);\r\n        Logger(ex);\r\n        try {\r\n            const { h32 } = (await xxhashOld()) as unknown as Exports;\r\n            hashFunc = (str) => h32(str);\r\n        } catch (ex) {\r\n            Logger(`Could not initialise old xxhash for plugin: use sha1`, LOG_LEVEL_VERBOSE);\r\n            Logger(ex);\r\n            hashFunc = (str) => str;\r\n        }\r\n    }\r\n    return hashFunc;\r\n}\r\ninitHashFunc();\r\n/**\r\n * Calculates the SHA-1 hash of the given string.\r\n * \r\n * @param src - The string to calculate the hash for.\r\n * @returns A promise that resolves to the SHA-1 hash as a base64-encoded string.\r\n */\r\nexport async function sha1(src: string): Promise<string> {\r\n    const bytes = writeString(src);\r\n    const digest = await globalThis.crypto.subtle.digest({ name: \"SHA-1\" }, bytes);\r\n    return await arrayBufferToBase64Single(digest);\r\n}\r\n\r\n/**\r\n * Calculates the digest hash of an array of strings using xxhash.\r\n * \r\n * @param src - The array of strings to calculate the hash for.\r\n * @returns The digest hash of the input array.\r\n */\r\nexport function digestHash(src: string[]): string {\r\n    let hash = \"\";\r\n    for (const v of src) {\r\n        hash = hashFunc(hash + v);\r\n    }\r\n    if (hash == \"\") {\r\n        return hashFunc(\"**\");\r\n    }\r\n    return hash;\r\n}\r\n"],"names":["xxhashNew"],"mappings":";;;;;;;;AASA,IAAI,QAAkD,CAAC;AAEvD,eAAe,YAAY,GAAA;AACvB,IAAA,IAAI;AACA,QAAA,MAAM,EAAE,WAAW,EAAE,GAAG,MAAOA,CAAiD,EAAE,CAAC;QACnF,QAAQ,GAAG,WAAW,CAAC;AACvB,QAAA,MAAM,CAAC,CAAA,6BAAA,CAA+B,EAAE,iBAAiB,CAAC,CAAC;KAC9D;IAAC,OAAO,EAAE,EAAE;AACT,QAAA,MAAM,CAAC,CAAA,wCAAA,CAA0C,EAAE,iBAAiB,CAAC,CAAC;QACtE,MAAM,CAAC,EAAE,CAAC,CAAC;AACX,QAAA,IAAI;YACA,MAAM,EAAE,GAAG,EAAE,IAAI,MAAM,SAAS,EAAE,CAAuB,CAAC;YAC1D,QAAQ,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;SAChC;QAAC,OAAO,EAAE,EAAE;AACT,YAAA,MAAM,CAAC,CAAA,oDAAA,CAAsD,EAAE,iBAAiB,CAAC,CAAC;YAClF,MAAM,CAAC,EAAE,CAAC,CAAC;AACX,YAAA,QAAQ,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC;SAC3B;KACJ;AACD,IAAA,OAAO,QAAQ,CAAC;AACpB,CAAC;AACD,YAAY,EAAE,CAAC;AACf;;;;;AAKG;AACI,eAAe,IAAI,CAAC,GAAW,EAAA;AAClC,IAAA,MAAM,KAAK,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC;AAC/B,IAAA,MAAM,MAAM,GAAG,MAAM,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,EAAE,KAAK,CAAC,CAAC;AAC/E,IAAA,OAAO,MAAM,yBAAyB,CAAC,MAAM,CAAC,CAAC;AACnD,CAAC;AAED;;;;;AAKG;AACG,SAAU,UAAU,CAAC,GAAa,EAAA;IACpC,IAAI,IAAI,GAAG,EAAE,CAAC;AACd,IAAA,KAAK,MAAM,CAAC,IAAI,GAAG,EAAE;AACjB,QAAA,IAAI,GAAG,QAAQ,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;KAC7B;AACD,IAAA,IAAI,IAAI,IAAI,EAAE,EAAE;AACZ,QAAA,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAC;KACzB;AACD,IAAA,OAAO,IAAI,CAAC;AAChB;;;;"}