{"version":3,"file":"xxhash.js","sources":["../../src/hash/xxhash.ts"],"sourcesContent":["import { default as xxhashOld, type Exports } from \"xxhash-wasm\";\n//@ts-ignore\nimport { default as xxhashNew } from \"../patched_xxhash_wasm/xxhash-wasm.js\";\nimport type { XXHashAPI } from \"xxhash-wasm-102\";\nimport { Logger, LOG_LEVEL_VERBOSE } from \"../common/logger.js\";\nimport { writeString, arrayBufferToBase64Single } from \"../binary\";\n\nexport { xxhashOld, xxhashNew }\n\nlet hashFunc: (input: string, seed?: number) => string;\n\nasync function initHashFunc() {\n    try {\n        const { h32ToString } = await (xxhashNew as unknown as () => Promise<XXHashAPI>)();\n        hashFunc = h32ToString;\n        Logger(`xxhash for plugin initialised`, LOG_LEVEL_VERBOSE);\n    } catch (ex) {\n        Logger(`Could not initialise xxhash. fallback...`, LOG_LEVEL_VERBOSE);\n        Logger(ex);\n        try {\n            const { h32 } = (await xxhashOld()) as unknown as Exports;\n            hashFunc = (str) => h32(str);\n        } catch (ex) {\n            Logger(`Could not initialise old xxhash for plugin: use sha1`, LOG_LEVEL_VERBOSE);\n            Logger(ex);\n            hashFunc = (str) => str;\n        }\n    }\n    return hashFunc;\n}\ninitHashFunc();\n/**\n * Calculates the SHA-1 hash of the given string.\n * \n * @param src - The string to calculate the hash for.\n * @returns A promise that resolves to the SHA-1 hash as a base64-encoded string.\n */\nexport async function sha1(src: string): Promise<string> {\n    const bytes = writeString(src);\n    const digest = await globalThis.crypto.subtle.digest({ name: \"SHA-1\" }, bytes);\n    return await arrayBufferToBase64Single(digest);\n}\n\n/**\n * Calculates the digest hash of an array of strings using xxhash.\n * \n * @param src - The array of strings to calculate the hash for.\n * @returns The digest hash of the input array.\n */\nexport function digestHash(src: string[]): string {\n    let hash = \"\";\n    for (const v of src) {\n        hash = hashFunc(hash + v);\n    }\n    if (hash == \"\") {\n        return hashFunc(\"**\");\n    }\n    return hash;\n}\n"],"names":["xxhashNew"],"mappings":";;;;;;;;AASA,IAAI,QAAkD;AAEtD,eAAe,YAAY,GAAA;AACvB,IAAA,IAAI;AACA,QAAA,MAAM,EAAE,WAAW,EAAE,GAAG,MAAOA,CAAiD,EAAE;QAClF,QAAQ,GAAG,WAAW;AACtB,QAAA,MAAM,CAAC,CAAA,6BAAA,CAA+B,EAAE,iBAAiB,CAAC;;IAC5D,OAAO,EAAE,EAAE;AACT,QAAA,MAAM,CAAC,CAAA,wCAAA,CAA0C,EAAE,iBAAiB,CAAC;QACrE,MAAM,CAAC,EAAE,CAAC;AACV,QAAA,IAAI;YACA,MAAM,EAAE,GAAG,EAAE,IAAI,MAAM,SAAS,EAAE,CAAuB;YACzD,QAAQ,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG,CAAC;;QAC9B,OAAO,EAAE,EAAE;AACT,YAAA,MAAM,CAAC,CAAA,oDAAA,CAAsD,EAAE,iBAAiB,CAAC;YACjF,MAAM,CAAC,EAAE,CAAC;AACV,YAAA,QAAQ,GAAG,CAAC,GAAG,KAAK,GAAG;;;AAG/B,IAAA,OAAO,QAAQ;AACnB;AACA,YAAY,EAAE;AACd;;;;;AAKG;AACI,eAAe,IAAI,CAAC,GAAW,EAAA;AAClC,IAAA,MAAM,KAAK,GAAG,WAAW,CAAC,GAAG,CAAC;AAC9B,IAAA,MAAM,MAAM,GAAG,MAAM,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,EAAE,KAAK,CAAC;AAC9E,IAAA,OAAO,MAAM,yBAAyB,CAAC,MAAM,CAAC;AAClD;AAEA;;;;;AAKG;AACG,SAAU,UAAU,CAAC,GAAa,EAAA;IACpC,IAAI,IAAI,GAAG,EAAE;AACb,IAAA,KAAK,MAAM,CAAC,IAAI,GAAG,EAAE;AACjB,QAAA,IAAI,GAAG,QAAQ,CAAC,IAAI,GAAG,CAAC,CAAC;;AAE7B,IAAA,IAAI,IAAI,IAAI,EAAE,EAAE;AACZ,QAAA,OAAO,QAAQ,CAAC,IAAI,CAAC;;AAEzB,IAAA,OAAO,IAAI;AACf;;;;"}