{"version":3,"file":"xxhash.js","sources":["../../src/hash/xxhash.ts"],"sourcesContent":["import { default as xxhashOld, type Exports } from \"xxhash-wasm\";\n//@ts-ignore\nimport { default as xxhashNew } from \"../patched_xxhash_wasm/xxhash-wasm.js\";\nimport type { XXHashAPI } from \"xxhash-wasm-102\";\nimport { Logger, LOG_LEVEL_VERBOSE } from \"../common/logger.js\";\nimport { writeString, arrayBufferToBase64Single } from \"../binary\";\n\nexport { xxhashOld, xxhashNew }\n\nlet hashFunc: (input: string, seed?: number) => string;\n\nasync function initHashFunc() {\n    try {\n        const { h32ToString } = await (xxhashNew as unknown as () => Promise<XXHashAPI>)();\n        hashFunc = h32ToString;\n        Logger(`xxhash for plugin initialised`, LOG_LEVEL_VERBOSE);\n    } catch (ex) {\n        Logger(`Could not initialise xxhash. fallback...`, LOG_LEVEL_VERBOSE);\n        Logger(ex);\n        try {\n            const { h32 } = (await xxhashOld()) as unknown as Exports;\n            hashFunc = (str) => h32(str);\n        } catch (ex) {\n            Logger(`Could not initialise old xxhash for plugin: use sha1`, LOG_LEVEL_VERBOSE);\n            Logger(ex);\n            hashFunc = (str) => str;\n        }\n    }\n    return hashFunc;\n}\ninitHashFunc();\n/**\n * Calculates the SHA-1 hash of the given string.\n * \n * @param src - The string to calculate the hash for.\n * @returns A promise that resolves to the SHA-1 hash as a base64-encoded string.\n */\nexport async function sha1(src: string): Promise<string> {\n    const bytes = writeString(src);\n    const digest = await globalThis.crypto.subtle.digest({ name: \"SHA-1\" }, bytes);\n    return await arrayBufferToBase64Single(digest);\n}\n\n/**\n * Calculates the digest hash of an array of strings using xxhash.\n * \n * @param src - The array of strings to calculate the hash for.\n * @returns The digest hash of the input array.\n */\nexport function digestHash(src: string[]): string {\n    let hash = \"\";\n    for (const v of src) {\n        hash = hashFunc(hash + v);\n    }\n    if (hash == \"\") {\n        return hashFunc(\"**\");\n    }\n    return hash;\n}\n"],"names":["xxhashNew"],"mappings":";;;;;;;;AASA,IAAI,QAAkD,CAAC;AAEvD,eAAe,YAAY,GAAA;AACvB,IAAA,IAAI;AACA,QAAA,MAAM,EAAE,WAAW,EAAE,GAAG,MAAOA,CAAiD,EAAE,CAAC;QACnF,QAAQ,GAAG,WAAW,CAAC;AACvB,QAAA,MAAM,CAAC,CAAA,6BAAA,CAA+B,EAAE,iBAAiB,CAAC,CAAC;KAC9D;IAAC,OAAO,EAAE,EAAE;AACT,QAAA,MAAM,CAAC,CAAA,wCAAA,CAA0C,EAAE,iBAAiB,CAAC,CAAC;QACtE,MAAM,CAAC,EAAE,CAAC,CAAC;AACX,QAAA,IAAI;YACA,MAAM,EAAE,GAAG,EAAE,IAAI,MAAM,SAAS,EAAE,CAAuB,CAAC;YAC1D,QAAQ,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;SAChC;QAAC,OAAO,EAAE,EAAE;AACT,YAAA,MAAM,CAAC,CAAA,oDAAA,CAAsD,EAAE,iBAAiB,CAAC,CAAC;YAClF,MAAM,CAAC,EAAE,CAAC,CAAC;AACX,YAAA,QAAQ,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC;SAC3B;KACJ;AACD,IAAA,OAAO,QAAQ,CAAC;AACpB,CAAC;AACD,YAAY,EAAE,CAAC;AACf;;;;;AAKG;AACI,eAAe,IAAI,CAAC,GAAW,EAAA;AAClC,IAAA,MAAM,KAAK,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC;AAC/B,IAAA,MAAM,MAAM,GAAG,MAAM,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,EAAE,KAAK,CAAC,CAAC;AAC/E,IAAA,OAAO,MAAM,yBAAyB,CAAC,MAAM,CAAC,CAAC;AACnD,CAAC;AAED;;;;;AAKG;AACG,SAAU,UAAU,CAAC,GAAa,EAAA;IACpC,IAAI,IAAI,GAAG,EAAE,CAAC;AACd,IAAA,KAAK,MAAM,CAAC,IAAI,GAAG,EAAE;AACjB,QAAA,IAAI,GAAG,QAAQ,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;KAC7B;AACD,IAAA,IAAI,IAAI,IAAI,EAAE,EAAE;AACZ,QAAA,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAC;KACzB;AACD,IAAA,OAAO,IAAI,CAAC;AAChB;;;;"}