{"version":3,"file":"signal_v1.js","sources":["../../src/messagepassing/signal_v1.ts"],"sourcesContent":["import { type RESULT_NOT_FOUND, RESULT_TIMED_OUT } from \"../common/const\";\n\nexport type WithTimeout<T> = T | typeof RESULT_TIMED_OUT;\nexport type WithNotFound<T> = T | typeof RESULT_NOT_FOUND;\n\nconst traps = {} as { [key: string]: ((param: any) => void)[]; };\n/**\n * Waits for a signal with the specified ID.\n * @param id - The ID of the signal to wait for.\n * @param timeout - The maximum time to wait for the signal, in milliseconds.\n * @returns A promise that resolves to `true` if the signal is received within the timeout, or `false` otherwise.\n */\nexport async function waitForSignal(id: string, timeout?: number): Promise<boolean> {\n    return await waitForValue(id, timeout) !== RESULT_TIMED_OUT;\n}\n/**\n * Waits for a value with the specified ID to be resolved.\n * \n * @param id - The ID of the value to wait for.\n * @param timeout - Optional timeout value in milliseconds. If the value is not resolved within the specified timeout, the promise will be rejected with a timeout error.\n * @returns A promise that resolves with the value or rejects with a timeout error.\n */\nexport function waitForValue<T>(id: string, timeout?: number): Promise<WithTimeout<T>> {\n    let resolveTrap: ((result: WithTimeout<T>) => void) | undefined;\n    let trapJob: (() => void) | ((param: T) => void);\n    const timer = timeout ? setTimeout(() => {\n        if (id in traps) {\n            traps[id] = traps[id].filter(e => e != trapJob);\n        }\n        if (resolveTrap) resolveTrap(RESULT_TIMED_OUT);\n        resolveTrap = undefined;\n    }, timeout) : false;\n    return new Promise((res) => {\n        if (!(id in traps)) traps[id] = [];\n        resolveTrap = res;\n        trapJob = (result: T) => {\n            if (timer) clearTimeout(timer);\n            res(result);\n        };\n        traps[id].push(trapJob);\n    });\n}\n\n/**\n * Sends a signal with the specified ID.\n * @param id - The ID of the signal.\n */\nexport function sendSignal(id: string) {\n    sendValue(id, true);\n}\n/**\n * Sends a value to the specified ID.\n * @param id - The ID to send the value to.\n * @param result - The value to send.\n */\nexport function sendValue<T>(id: string, result: T) {\n    if (!(id in traps)) {\n        return;\n    }\n    const trap = traps[id];\n    delete traps[id];\n    for (const resolver of trap) {\n        resolver(result);\n    }\n}\n"],"names":[],"mappings":";;AAKA,MAAM,KAAK,GAAG,EAAkD;AAChE;;;;;AAKG;AACI,eAAe,aAAa,CAAC,EAAU,EAAE,OAAgB,EAAA;IAC5D,OAAO,MAAM,YAAY,CAAC,EAAE,EAAE,OAAO,CAAC,KAAK,gBAAgB;AAC/D;AACA;;;;;;AAMG;AACa,SAAA,YAAY,CAAI,EAAU,EAAE,OAAgB,EAAA;AACxD,IAAA,IAAI,WAA2D;AAC/D,IAAA,IAAI,OAA4C;IAChD,MAAM,KAAK,GAAG,OAAO,GAAG,UAAU,CAAC,MAAK;AACpC,QAAA,IAAI,EAAE,IAAI,KAAK,EAAE;AACb,YAAA,KAAK,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC;;AAEnD,QAAA,IAAI,WAAW;YAAE,WAAW,CAAC,gBAAgB,CAAC;QAC9C,WAAW,GAAG,SAAS;AAC3B,KAAC,EAAE,OAAO,CAAC,GAAG,KAAK;AACnB,IAAA,OAAO,IAAI,OAAO,CAAC,CAAC,GAAG,KAAI;AACvB,QAAA,IAAI,EAAE,EAAE,IAAI,KAAK,CAAC;AAAE,YAAA,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE;QAClC,WAAW,GAAG,GAAG;AACjB,QAAA,OAAO,GAAG,CAAC,MAAS,KAAI;AACpB,YAAA,IAAI,KAAK;gBAAE,YAAY,CAAC,KAAK,CAAC;YAC9B,GAAG,CAAC,MAAM,CAAC;AACf,SAAC;QACD,KAAK,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC;AAC3B,KAAC,CAAC;AACN;AAEA;;;AAGG;AACG,SAAU,UAAU,CAAC,EAAU,EAAA;AACjC,IAAA,SAAS,CAAC,EAAE,EAAE,IAAI,CAAC;AACvB;AACA;;;;AAIG;AACa,SAAA,SAAS,CAAI,EAAU,EAAE,MAAS,EAAA;AAC9C,IAAA,IAAI,EAAE,EAAE,IAAI,KAAK,CAAC,EAAE;QAChB;;AAEJ,IAAA,MAAM,IAAI,GAAG,KAAK,CAAC,EAAE,CAAC;AACtB,IAAA,OAAO,KAAK,CAAC,EAAE,CAAC;AAChB,IAAA,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE;QACzB,QAAQ,CAAC,MAAM,CAAC;;AAExB;;;;"}