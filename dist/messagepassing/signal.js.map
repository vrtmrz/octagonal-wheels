{"version":3,"file":"signal.js","sources":["../../src/messagepassing/signal.ts"],"sourcesContent":["import { RESULT_NOT_FOUND, RESULT_TIMED_OUT } from \"../common/const\";\r\n\r\nexport type WithTimeout<T> = T | typeof RESULT_TIMED_OUT;\r\nexport type WithNotFound<T> = T | typeof RESULT_NOT_FOUND;\r\n\r\nconst traps = {} as { [key: string]: ((param: any) => void)[]; }\r\n/**\r\n * Waits for a signal with the specified ID.\r\n * @param id - The ID of the signal to wait for.\r\n * @param timeout - The maximum time to wait for the signal, in milliseconds.\r\n * @returns A promise that resolves to `true` if the signal is received within the timeout, or `false` otherwise.\r\n */\r\nexport async function waitForSignal(id: string, timeout?: number): Promise<boolean> {\r\n    return await waitForValue(id, timeout) !== RESULT_TIMED_OUT;\r\n}\r\n/**\r\n * Waits for a value with the specified ID to be resolved.\r\n * \r\n * @param id - The ID of the value to wait for.\r\n * @param timeout - Optional timeout value in milliseconds. If the value is not resolved within the specified timeout, the promise will be rejected with a timeout error.\r\n * @returns A promise that resolves with the value or rejects with a timeout error.\r\n */\r\nexport function waitForValue<T>(id: string, timeout?: number): Promise<WithTimeout<T>> {\r\n    let resolveTrap: ((result: WithTimeout<T>) => void) | undefined;\r\n    let trapJob: (() => void) | ((param: T) => void);\r\n    const timer = timeout ? setTimeout(() => {\r\n        if (id in traps) {\r\n            traps[id] = traps[id].filter(e => e != trapJob);\r\n        }\r\n        if (resolveTrap) resolveTrap(RESULT_TIMED_OUT);\r\n        resolveTrap = undefined;\r\n    }, timeout) : false\r\n    return new Promise((res) => {\r\n        if (!(id in traps)) traps[id] = [];\r\n        resolveTrap = res;\r\n        trapJob = (result: T) => {\r\n            if (timer) clearTimeout(timer);\r\n            res(result);\r\n        }\r\n        traps[id].push(trapJob);\r\n    });\r\n}\r\n\r\n/**\r\n * Sends a signal with the specified ID.\r\n * @param id - The ID of the signal.\r\n */\r\nexport function sendSignal(id: string) {\r\n    sendValue(id, true);\r\n}\r\n/**\r\n * Sends a value to the specified ID.\r\n * @param id - The ID to send the value to.\r\n * @param result - The value to send.\r\n */\r\nexport function sendValue<T>(id: string, result: T) {\r\n    if (!(id in traps)) {\r\n        return;\r\n    }\r\n    const trap = traps[id];\r\n    delete traps[id];\r\n    for (const resolver of trap) {\r\n        resolver(result);\r\n    }\r\n}\r\n"],"names":[],"mappings":";;AAKA,MAAM,KAAK,GAAG,EAAkD,CAAA;AAChE;;;;;AAKG;AACI,eAAe,aAAa,CAAC,EAAU,EAAE,OAAgB,EAAA;IAC5D,OAAO,MAAM,YAAY,CAAC,EAAE,EAAE,OAAO,CAAC,KAAK,gBAAgB,CAAC;AAChE,CAAC;AACD;;;;;;AAMG;AACa,SAAA,YAAY,CAAI,EAAU,EAAE,OAAgB,EAAA;AACxD,IAAA,IAAI,WAA2D,CAAC;AAChE,IAAA,IAAI,OAA4C,CAAC;IACjD,MAAM,KAAK,GAAG,OAAO,GAAG,UAAU,CAAC,MAAK;AACpC,QAAA,IAAI,EAAE,IAAI,KAAK,EAAE;AACb,YAAA,KAAK,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,CAAC;SACnD;AACD,QAAA,IAAI,WAAW;YAAE,WAAW,CAAC,gBAAgB,CAAC,CAAC;QAC/C,WAAW,GAAG,SAAS,CAAC;AAC5B,KAAC,EAAE,OAAO,CAAC,GAAG,KAAK,CAAA;AACnB,IAAA,OAAO,IAAI,OAAO,CAAC,CAAC,GAAG,KAAI;AACvB,QAAA,IAAI,EAAE,EAAE,IAAI,KAAK,CAAC;AAAE,YAAA,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC;QACnC,WAAW,GAAG,GAAG,CAAC;AAClB,QAAA,OAAO,GAAG,CAAC,MAAS,KAAI;AACpB,YAAA,IAAI,KAAK;gBAAE,YAAY,CAAC,KAAK,CAAC,CAAC;YAC/B,GAAG,CAAC,MAAM,CAAC,CAAC;AAChB,SAAC,CAAA;QACD,KAAK,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AAC5B,KAAC,CAAC,CAAC;AACP,CAAC;AAED;;;AAGG;AACG,SAAU,UAAU,CAAC,EAAU,EAAA;AACjC,IAAA,SAAS,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;AACxB,CAAC;AACD;;;;AAIG;AACa,SAAA,SAAS,CAAI,EAAU,EAAE,MAAS,EAAA;AAC9C,IAAA,IAAI,EAAE,EAAE,IAAI,KAAK,CAAC,EAAE;QAChB,OAAO;KACV;AACD,IAAA,MAAM,IAAI,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC;AACvB,IAAA,OAAO,KAAK,CAAC,EAAE,CAAC,CAAC;AACjB,IAAA,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE;QACzB,QAAQ,CAAC,MAAM,CAAC,CAAC;KACpB;AACL;;;;"}