{"version":3,"file":"SlipBoard.js","sources":["../../src/bureau/SlipBoard.ts"],"sourcesContent":["import { cancelableDelay, fireAndForget, promiseWithResolver, TIMED_OUT_SIGNAL, yieldMicrotask, type PromiseWithResolvers } from \"../promises\";\nimport { RESULT_TIMED_OUT } from \"../common/const\";\n\nexport type WithTimeout<T> = T | typeof RESULT_TIMED_OUT;\nconst GENERIC_COMPATIBILITY_VALUE = \"x-compatibility-value\";\nconst GENERIC_COMPATIBILITY_SIGNAL = \"x-compatibility-signal\";\n\ndeclare global {\n    /**\n     * The ype of slips that can be used in the SlipBoard\n     */\n    interface LSSlips {\n        \"wait-for-timeout\": boolean;\n        // \"dummy\": undefined;\n        [GENERIC_COMPATIBILITY_VALUE]: any;\n        [GENERIC_COMPATIBILITY_SIGNAL]: undefined;\n    }\n}\n\ntype SlipWithData<ET, K> = K extends keyof ET ? (ET[K] extends undefined ? never : K extends string ? K : never) : never;\ntype SlipWithoutData<ET, K> = K extends keyof ET ? (ET[K] extends undefined ? K extends string ? K : never : never) : never;\ntype SlipType<ET, K> = SlipWithoutData<ET, K> | SlipWithData<ET, K> | K extends string ? K : never;\n\n\ntype SlipDataType<ET extends Record<string, any>, K extends keyof ET> = ET[K] extends undefined ? undefined : ET[K];\ntype ResultType<ET extends Record<string, any>, K extends keyof ET> = ET[K] extends undefined ? void : ET[K];\n\n\nexport type SlipProcessOptions<T> = {\n    callback: () => Promise<T> | T;\n} & (\n        { submitAsSuccess?: false, dropSlipWithRisks?: boolean; } |\n        { submitAsSuccess: true, transformError?: (error: any) => any; }\n    );\n/**\n * A Class for wait \n */\n\nexport type AwaitOptionBase = {\n    onNotAwaited?: () => void;\n};\nexport type AwaitOptionWithoutTimeout = (AwaitOptionBase & { timeout?: undefined | false; });\nexport type AwaitOptionWithTimeout = AwaitOptionBase & { timeout?: number; };\ntype AwaitOption = AwaitOptionWithoutTimeout | AwaitOptionWithTimeout;\n\nexport class SlipBoard<Events extends LSSlips = LSSlips> {\n\n    _clip = new Map<string | symbol | number, PromiseWithResolvers<any>>();\n\n    /**\n     * Checks if a specific key is awaiting.\n     *\n     * @template ET - The type of the events.\n     * @template K - The key of the event in the events type.\n     * @param {SlipType<ET, K>} type - The key representing the event type.\n     * @param {string} key - The key representing the specific sub-event.\n     * @returns {boolean} - Returns `true` if the event and sub-event combination is awaiting, otherwise `false`.\n     */\n    isAwaiting<ET extends Events, K extends keyof ET>(type: SlipType<ET, K>, key: string): boolean {\n        return this._clip.has(`${String(type)}:${key}`);\n    }\n\n\n    /**\n     * Issues a slip of process and proceeds with the provided options.\n     *\n     * @template T - The type of the result expected from the process.\n     * @param {string} type - The type of the process to be issued.\n     * @param {string} [key=\"\"] - An optional key to identify the process.\n     * @param {SlipProcessOptions<T>} opt - The options for the process, including the callback to be executed.\n     * @returns {Promise<T>} - A promise that resolves with the result of the process.\n     *\n     * @remarks\n     * - If the process is not already awaiting, it will be issued and the callback will be executed.\n     * - If the callback succeeds, the result will be submitted.\n     * - If the callback fails, the error handling depends on the options provided:\n     *   - If `submitAsSuccess` is true, the error (or transformed error) will be submitted as a success.\n     *   - If `dropSlipWithRisks` is true, the process will be deleted from the clip.\n     *   - Otherwise, the error will be rejected.\n     * - The method returns a promise that resolves with the next result of the process.\n     */\n    issueAndProceed<T>(type: string, key: string = \"\", opt: SlipProcessOptions<T>): Promise<T> {\n        // This key is not necessary to be member of events, because that is expected to be used only via this method.\n        if (!this.isAwaiting(type as any, key)) {\n            fireAndForget(async () => {\n                try {\n                    const ret = await opt.callback();\n                    this.submit(type as any, key, ret);\n                } catch (ex) {\n                    if (opt.submitAsSuccess) {\n                        this.submit(type as any, key, opt.transformError ? opt.transformError(ex) : ex);\n                    } else {\n                        if (opt.dropSlipWithRisks) {\n                            this._clip.delete(type);\n                            // If the caller waits for the result and it would waiting without timeout, it will be waiting forever.\n                        } else {\n                            this.reject(type as any, key, ex);\n                        }\n                    }\n                }\n            });\n        }\n        return this.awaitNext(type as any, key) as Promise<T>;\n    }\n\n    awaitNext<ET extends Events, K extends keyof ET>(type: K, key: string, opt?: AwaitOptionWithoutTimeout): Promise<ResultType<ET, K>>;\n    awaitNext<ET extends Events, K extends keyof ET>(type: K, key: string, opt?: AwaitOptionWithTimeout): Promise<ResultType<ET, K> | TIMED_OUT_SIGNAL>;\n    /**\n     * Waits for the next event of the specified type and key, with an optional timeout.\n     *\n     * @template ET - The type of the events.\n     * @template K - The key of the event type.\n     * @param {SlipType<ET, K>} type - The type of the event to wait for.\n     * @param {string} [key=\"\"] - The key associated with the event.\n     * @param {number} [timeout] - The optional timeout in milliseconds.\n     * @returns {Promise<void | ET[K] | TIMED_OUT_SIGNAL>} A promise that resolves with the event data, \n     * resolves with `TIMED_OUT_SIGNAL` if the timeout is reached, or resolves to void if no event is found.\n     */\n    async awaitNext<ET extends Events, K extends keyof ET>(type: K, key: string = \"\", { timeout, onNotAwaited }: AwaitOption = { timeout: undefined, onNotAwaited: undefined }): Promise<ResultType<ET, K> | TIMED_OUT_SIGNAL> {\n        let taskPromise = this._clip.get(`${String(type)}:${key}`);\n        if (!taskPromise) {\n            taskPromise = promiseWithResolver<void | ET[K]>();\n            taskPromise.promise = taskPromise.promise.then((ret: unknown) => {\n                // this.clip.delete(key);\n                return ret;\n            }).finally(() => {\n                this._clip.delete(`${String(type)}:${key}`);\n            });\n            this._clip.set(`${String(type)}:${key}`, taskPromise);\n            if (onNotAwaited) {\n                fireAndForget(async () => (await yieldMicrotask(), onNotAwaited()));\n            }\n        }\n        if (timeout) {\n            const cDelay = cancelableDelay(timeout);\n            return Promise.race([cDelay.promise, taskPromise.promise.then((ret: any) => ret).finally(() => cDelay.cancel())]);\n        }\n        return await taskPromise.promise;\n    }\n\n    submit<ET extends Events, K extends keyof ET>(\n        type: SlipWithoutData<ET, K>, key: string\n    ): void;\n    submit<ET extends Events, K extends keyof ET>(\n        type: SlipWithData<ET, K>, key: string,\n        data: ET[K]\n    ): void;\n    /**\n     * Submits an event of a specified type with optional data.\n     *\n     * @template ET - The type of events.\n     * @template K - The key of the event type in ET.\n     * @param {SlipType<ET, K>} type - The type of the event to submit.\n     * @param {string} [key=\"\"] - An optional key associated with the event.\n     * @param {SlipDataType<ET, K>} [data] - Optional data to be passed with the event.\n     * @returns {void}\n     */\n    submit<ET extends Events, K extends keyof ET>(\n        type: SlipType<ET, K>, key: string,\n        data?: SlipDataType<ET, K>\n    ): void {\n        const taskPromise = this._clip.get(`${String(type)}:${key}`);\n        if (taskPromise) {\n            taskPromise.resolve(data);\n        }\n    }\n\n    submitToAll<ET extends Events, K extends keyof ET>(\n        type: SlipWithoutData<ET, K>,\n        prefix: string\n    ): void;\n    submitToAll<ET extends Events, K extends keyof ET>(\n        type: SlipWithData<ET, K>,\n        prefix: string,\n        data: ET[K]\n    ): void;\n    /**\n     * Submits an event of a specified type to all listeners.\n     *\n     * @template ET - The type of events.\n     * @template K - The key of the event type in ET.\n     * @param {SlipType<ET, K>} type - The type of the event to submit.\n     * @param {string} prefix - The prefix to match the keys of the listeners.\n     * @param {SlipDataType<ET, K>} [data] - Optional data to be passed with the event.\n     * @returns {void}\n     */\n    submitToAll<ET extends Events, K extends keyof ET>(\n        type: SlipType<ET, K>,\n        prefix: string,\n        data?: SlipDataType<ET, K>\n    ): void {\n        for (const [key, taskPromise] of this._clip.entries()) {\n            if (`${String(key)}`.startsWith(`${String(type)}:${prefix}`)) {\n                taskPromise.resolve(data);\n            }\n        }\n    }\n    /**\n     * Rejects a task promise associated with a specific event type and key.\n     *\n     * @template ET - The type of events.\n     * @template K - The keys of the events.\n     * @param {SlipType<ET, K>} type - The type of the event.\n     * @param {string} [key=\"\"] - The key associated with the event. Defaults to an empty string.\n     * @param {any} reason - The reason for rejecting the promise.\n     */\n    reject<ET extends Events, K extends keyof ET>(\n        type: SlipType<ET, K>, key: string = \"\",\n        reason: any\n    ) {\n        const taskPromise = this._clip.get(`${String(type)}:${key}`);\n        if (taskPromise) {\n            taskPromise.reject(reason);\n        }\n    }\n\n\n}\n\n\n\nexport const globalSlipBoard = new SlipBoard();\n\n\nexport async function waitForSignal(id: string, timeout?: number): Promise<boolean> {\n    return await globalSlipBoard.awaitNext(GENERIC_COMPATIBILITY_SIGNAL, id, { timeout }) !== TIMED_OUT_SIGNAL;\n}\n\nexport async function waitForValue<T>(id: string, timeout?: number): Promise<WithTimeout<T>> {\n    const ret = await globalSlipBoard.awaitNext(GENERIC_COMPATIBILITY_VALUE, id, { timeout });\n    if (ret === TIMED_OUT_SIGNAL) {\n        return RESULT_TIMED_OUT;\n    }\n    return ret as T;\n}\n\nexport function sendSignal(id: string) {\n    globalSlipBoard.submit(GENERIC_COMPATIBILITY_SIGNAL, id);\n}\n/**\n * Sends a value to the specified ID.\n * @param id - The ID to send the value to.\n * @param result - The value to send.\n */\nexport function sendValue<T>(id: string, result: T) {\n    globalSlipBoard.submit(GENERIC_COMPATIBILITY_VALUE, id, result as any);\n}\n"],"names":[],"mappings":"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"}