{"version":3,"file":"manifold.js","sources":["../../src/conduit/manifold.ts"],"sourcesContent":["import { LOG_LEVEL_VERBOSE, Logger } from \"../common/logger\";\n\n/*\n * Manifold\n */\ntype ManifoldFunc<T extends any[]> = (...args: T) => Promise<boolean | void | undefined>;\n\n/**\n * Manifold\n * A manifold is a collection of functions that can be added, removed to invoke them with a set of arguments\n */\ninterface Manifold<T extends any[]> {\n\t/**\n\t * Add a function to the manifold\n\t * @param func The function to add to the manifold\n\t * @returns \n\t */\n\tadd: (func: ManifoldFunc<T>) => void;\n\t/**\n\t * \n\t * @param func The function to remove from the manifold\n\t * @returns \n\t */\n\tremove: (func: ManifoldFunc<T>) => void;\n\t/**\n\t * Clear all functions from the manifold\n\t * @returns \n\t */\n\tclear: () => void;\n\t/**\n\t * \n\t * @param func The function to set as the only function in the manifold\n\t * @description This will clear all other functions from the manifold\n\t * @returns \n\t */\n\tset: (func: ManifoldFunc<T>) => void;\n\t/**\n\t * Invoke all associated functions until one returns true\n\t * @param args The arguments to pass to the functions in the manifold\n\t * @returns if any function returns true\n\t * @description If no functions are in the manifold, this will return false\n\t */\n\tsome: (...args: T) => Promise<boolean>;\n\t/**\n\t * Invoke all associated functions until one returns true\n\t * @param args The arguments to pass to the functions in the manifold\n\t * @returns if any function returns true\n\t * @description If no functions are in the manifold, this will return true\n\t */\n\tany: (...args: T) => Promise<boolean>;\n\t/**\n\t * Invoke all associated functions until one returns false\n\t * @param args The arguments to pass to the functions in the manifold\n\t * @returns if all functions return true\n\t * @description If no functions are in the manifold, this will return true\n\t */\n\tevery: (...args: T) => Promise<boolean>;\n\t/**\n\t * Invoke all associated functions until one returns false\n\t * @param args The arguments to pass to the functions in the manifold\n\t * @returns if all functions return true\n\t * @description If no functions are in the manifold, this will return false\n\t */\n\tall: (...args: T) => Promise<boolean>;\n}\n/**\n * Create a manifold (Internal)\n * @param name The name of the manifold\n * @returns A manifold\n * @description A manifold is a collection of functions that can be added, removed to invoke them with a set of arguments\n */\nfunction createManifold<T extends any[]>(name: string): Manifold<T> {\n\tconst functions = new Set<ManifoldFunc<T>>();\n\tconst add = (func: ManifoldFunc<T>) => {\n\t\tfunctions.add(func);\n\t}\n\tconst remove = (func: ManifoldFunc<T>) => {\n\t\tfunctions.delete(func);\n\t}\n\tconst clear = () => {\n\t\tfunctions.clear();\n\t}\n\tconst set = (func: ManifoldFunc<T>) => {\n\t\tfunctions.clear();\n\t\tfunctions.add(func);\n\t}\n\tconst some = async (...args: T) => {\n\t\tif (functions.size === 0) {\n\t\t\treturn false\n\t\t}\n\t\tfor (const func of functions) {\n\t\t\ttry {\n\t\t\t\tconst result = await func(...args);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tLogger(`[Manifold](${name}.some) Error in function: ${func.name}`);\n\t\t\t\tLogger(e, LOG_LEVEL_VERBOSE);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tconst any = async (...args: T) => {\n\t\tif (functions.size === 0) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (const func of functions) {\n\t\t\ttry {\n\t\t\t\tconst result = await func(...args);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tLogger(`[Manifold](${name}.any) Error in function: ${func.name}`);\n\t\t\t\tLogger(e, LOG_LEVEL_VERBOSE);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tconst every = async (...args: T) => {\n\t\tif (functions.size === 0) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (const func of functions) {\n\t\t\ttry {\n\t\t\t\tconst result = await func(...args);\n\t\t\t\tif (!result) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tLogger(`[Manifold](${name}.every) Error in function: ${func.name}`);\n\t\t\t\tLogger(e, LOG_LEVEL_VERBOSE);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tconst all = async (...args: T) => {\n\t\tif (functions.size === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (const func of functions) {\n\t\t\ttry {\n\t\t\t\tconst result = await func(...args);\n\t\t\t\tif (!result) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tLogger(`[Manifold](${name}.all) Error in function: ${func.name}`);\n\t\t\t\tLogger(e, LOG_LEVEL_VERBOSE);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn {\n\t\tadd,\n\t\tremove,\n\t\tclear,\n\t\tset,\n\t\tsome,\n\t\tany,\n\t\tevery,\n\t\tall\n\t}\n}\nconst manifolds = new Map<string, Manifold<any>>();\n\nexport const Manifold = {\n\tof: <T extends any[]>(name: string): Manifold<T> => {\n\t\tif (manifolds.has(name)) {\n\t\t\treturn manifolds.get(name) as Manifold<T>;\n\t\t}\n\t\tconst manifold = createManifold<T>(name);\n\t\tmanifolds.set(name, manifold);\n\t\treturn manifold;\n\t}\n}"],"names":[],"mappings":"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"}