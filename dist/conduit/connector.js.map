{"version":3,"file":"connector.js","sources":["../../src/conduit/connector.ts"],"sourcesContent":["import { promiseWithResolver } from \"../promises\";\n\n\n/**\n * ConnectorFunc\n * @description\n * ConnectorFunc is a function that takes a set of arguments and returns a promise.\n * It is used to connect a function to a name, and then invoke that function later.\n * @param T the type of the arguments\n * @param U the type of the return value\n * @returns a promise that resolves to the return value of the function\n */\nexport type ConnectorFunc<T extends any[], U> = (...args: T) => U\nexport type ConnectorWrappedFunc<T extends any[], U> = (...args: T) => U | Promise<Awaited<U>>;\n/**\n * ConnectorInstance\n * @description\n * ConnectorInstance is a type that represents an instance of a class.\n * It is used to connect an instance to a name, and then retrieve that instance later.\n * @param T the type of the instance\n */\nexport type ConnectorInstance<T> = T\n/**\n * ConnectorFuncOf\n * @description\n * Connect and invoke a function via connector.\n * It is used to connect a function to a name, and then invoke that function later.\n * @param T the type of the arguments\n * @param U the type of the return value\n */\nexport interface ConnectorFuncOf<T extends any[], U> {\n    /**\n     * Connect a function to the connector\n     * @description\n     * @param func The function to connect\n     * @param teardown Optional callback to be called when the function is disconnected\n     */\n    connect(func: ConnectorFunc<T, U>, teardown?: () => void): void;\n    /**\n     * Invoke the connected function\n     * @description If no function is connected yet, this will wait for the function to be connected and then invoke it.\n     * @param args The arguments to pass to the function\n     * @returns result of the function\n     */\n    invoke(...args: T): Promise<Awaited<U>>;\n    /**\n     * Invoke the connected function synchronously\n     * @description If no function is connected yet, this will throw an error.\n     * @param args The arguments to pass to the function\n     * @returns result of the function\n     */\n    invokeSync(...args: T): U;\n    /**\n     * Disconnect the connected function\n     * @description\n     * This will remove the function from the connector and clear the connection.\n     * @returns void\n     */\n    disconnect(): void;\n}\n/**\n * ConnectorInstanceOf\n * @description\n * Connect and get an instance via connector.\n * It is used to connect an instance to a name, and then retrieve that instance later.\n * @param T the type of the instance\n * @returns a promise that resolves to the instance\n */\nexport interface ConnectorInstanceOf<T> {\n    /**\n     * Connect an instance to the connector\n     * @description\n     * @param obj The instance to connect\n     * @param teardown Optional callback to be called when the instance is disconnected\n     */\n    connect(obj: T, teardown?: () => void): void;\n    /**\n     * Get the connected instance\n     * @description\n     * @returns a promise that resolves to the connected instance\n     */\n    connected(): Promise<T>;\n    /**\n     * Disconnect the connected instance\n     * @description\n     * This will remove the instance from the connector and clear the connection.\n     * @returns void\n     */\n    disconnect(): void;\n}\n\nfunction getFuncOf<T extends any[], U>(name: string): ConnectorFuncOf<T, U> {\n\n    let connectedFunction: ConnectorFunc<T, U> | undefined;\n    let connectedFunctionTask = promiseWithResolver<ConnectorFunc<T, U>>();\n    let onDisconnect: (() => void) | undefined;\n    const inst = {\n        connect: (func: ConnectorFunc<T, U>, onDisconnectCallback?: () => void) => {\n            if (connectedFunction) {\n                inst.disconnect();\n            }\n            connectedFunctionTask.resolve(func);\n            connectedFunction = func;\n            onDisconnect = onDisconnectCallback;\n        },\n        invoke: async (...args: T): Promise<Awaited<U>> => {\n            if (connectedFunction) {\n                return await connectedFunction(...args);\n            }\n            const func = await connectedFunctionTask.promise;\n            return await func(...args);\n        },\n        invokeSync: (...args: T): U => {\n            if (!connectedFunction) {\n                throw new Error(`Function not connected: ${name}`);\n            }\n            return connectedFunction(...args);\n        },\n        disconnect: () => {\n            connectedFunction = undefined;\n            connectedFunctionTask = promiseWithResolver<ConnectorFunc<T, U>>();\n            onDisconnect?.();\n            onDisconnect = undefined;\n        }\n    } satisfies ConnectorFuncOf<T, U>;\n    return inst;\n}\n\nfunction getInstanceOf<T>(name: string): ConnectorInstanceOf<T> {\n    let connectedInstance = promiseWithResolver<ConnectorInstance<T>>();\n    let instance: T | undefined = undefined;\n    let onDisconnect: (() => void) | undefined;\n    const inst = {\n        connect: (obj: T, onDisconnectCallback?: () => void) => {\n            if (instance) {\n                inst.disconnect();\n            }\n            connectedInstance.resolve(obj);\n            instance = obj;\n            onDisconnect = onDisconnectCallback;\n        },\n        connected: async (): Promise<T> => {\n            if (instance) {\n                return instance;\n            }\n            return await connectedInstance.promise;\n        },\n        disconnect: () => {\n            instance = undefined;\n            connectedInstance = promiseWithResolver<ConnectorInstance<T>>();\n            onDisconnect?.();\n            onDisconnect = undefined;\n        }\n    } satisfies ConnectorInstanceOf<T>;\n    return inst;\n}\n\nconst connectedFunctionsOf = new Map<string, ConnectorFuncOf<any, any>>();\nconst connectedInstancesOf = new Map<string, ConnectorInstanceOf<any>>();\n\nconst weakFuncMap = new WeakMap<ConnectorFunc<any, any>, string>();\nconst weakInstanceMap = new WeakMap<ConnectorInstance<any>, string>();\n\n/**\n* Get a function connector\n* @description \n* This method returns a function connector that allows you to connect a function to a name and then invoke that function later.\n* @param func A function to connect \n* @returns <ConnectorFuncOf<T, U>>\n*/\nfunction funcOf<T extends any[], U>(param: string | ConnectorFunc<T, U>): ConnectorFuncOf<T, U> {\n    let name: string;\n    if (typeof param === \"function\") {\n        if (weakFuncMap.has(param)) {\n            name = `func-${weakFuncMap.get(param)}`;\n        } else {\n            const id = Date.now().toString(36) + Math.random().toString(36).substring(2, 15);\n            weakFuncMap.set(param, id);\n            name = `func-${id}`;\n        }\n    } else {\n        name = param;\n    }\n\n    if (connectedFunctionsOf.has(name)) {\n        return connectedFunctionsOf.get(name) as ConnectorFuncOf<T, U>;\n    }\n    const func = getFuncOf<T, U>(name);\n    connectedFunctionsOf.set(name, func);\n    return func;\n}\n/**\n * Get a connector to instance by the name (internal function)\n * @param name The name of the instance (decided by each type of instance)\n * @description This function retrieves the connector instance associated with the given name.\n * @returns The connector instance associated with the name.\n     */\nfunction _instanceOf<T>(name: string) {\n    if (connectedInstancesOf.has(name)) {\n        return connectedInstancesOf.get(name) as ConnectorInstanceOf<T>;\n    }\n    const instance = getInstanceOf<T>(name);\n    connectedInstancesOf.set(name, instance);\n    return instance;\n}\n\ntype _classType<T> = new (...args: any[]) => T;\n\n/**\n * Get a class instance connector\n * @param classType The class type to connect\n * @returns The connector instance associated with the class instance.\n */\nfunction classInstanceOf<T extends new (...args: any[]) => any>(classType: T): ConnectorInstanceOf<InstanceType<T>>;\n/** \n *  Get a class instance connector by name\n * @description This function retrieves the connector instance associated with the given name.\n * @param name The name of the class type to connect\n * @returns The connector instance associated with the class type.\n */\nfunction classInstanceOf<T extends _classType<any>>(name: string): ConnectorInstanceOf<InstanceType<T>>;\nfunction classInstanceOf<T extends _classType<any>, N extends string = string>(classType: T | N): ConnectorInstanceOf<InstanceType<T>> {\n    if (typeof classType === \"string\") {\n        return _instanceOf<InstanceType<T>>(classType);\n    }\n    let name: string;\n    if (classType && typeof classType === \"function\" && classType.name) {\n        name = classType.name;\n    } else {\n        throw new Error(\"Seems not a class type, please provide a class type or a name\");\n    }\n    return _instanceOf<InstanceType<T>>(name);\n}\n\nfunction objectInstanceOf<T extends object>(instanceObject: T): ConnectorInstanceOf<T> {\n    let name: string | undefined;\n    if (\"name\" in instanceObject && typeof instanceObject.name === \"string\") {\n        name = instanceObject.name;\n    }\n    if (!name) {\n        if (weakInstanceMap.has(instanceObject)) {\n            name = `instance-${weakInstanceMap.get(instanceObject)}`;\n        } else {\n            const id = Date.now().toString(36) + Math.random().toString(36).substring(2, 15);\n            weakInstanceMap.set(instanceObject, id);\n            name = `instance-${id}`;\n        }\n    }\n    return _instanceOf<T>(name);\n}\n\n\n/**\n * Get a connector to instance by the name\n * @description\n * This method returns a instance connector that allows you to connect a instance to a name and then retrieve that instance later.\n * @param name The name of the instance to connect.\n * @returns <ConnectorInstanceOf<T>>\n */\nfunction instanceOf<T>(name: string): ConnectorInstanceOf<T>;\n/**\n * Get a connector to instance by the instance object\n * @description \n * This method returns a instance connector that allows you to connect a instance to a name and then retrieve that instance later.\n * @template T The type of the instance\n * @param instanceObject The instance object to connect\n */\nfunction instanceOf<T extends object>(instanceObject: T): ConnectorInstanceOf<T>;\nfunction instanceOf<T extends object>(param: string | T): ConnectorInstanceOf<T> {\n    if (typeof param === \"string\") {\n        return _instanceOf<T>(param);\n    }\n    return objectInstanceOf(param);\n}\n\n\n\n/**\n * Connector\n * @description\n * Connector is a utility class that allows you to connect functions and instances.\n * It provides a way to connect a function or an instance to a name, and then invoke that function or instance later.\n */\nexport const Connector = {\n    funcOf,\n    instanceOf,\n    classInstanceOf\n} as const;"],"names":[],"mappings":"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"}