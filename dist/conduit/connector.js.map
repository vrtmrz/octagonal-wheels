{"version":3,"file":"connector.js","sources":["../../src/conduit/connector.ts"],"sourcesContent":["import { promiseWithResolver } from \"../promises\";\n\n\n/**\n * ConnectorFunc\n * @description\n * ConnectorFunc is a function that takes a set of arguments and returns a promise.\n * It is used to connect a function to a name, and then invoke that function later.\n * @param T the type of the arguments\n * @param U the type of the return value\n * @returns a promise that resolves to the return value of the function\n */\nexport type ConnectorFunc<T extends any[], U> = (...args: T) => U\nexport type ConnectorWrappedFunc<T extends any[], U> = (...args: T) => U | Promise<Awaited<U>>;\n/**\n * ConnectorInstance\n * @description\n * ConnectorInstance is a type that represents an instance of a class.\n * It is used to connect an instance to a name, and then retrieve that instance later.\n * @param T the type of the instance\n */\nexport type ConnectorInstance<T> = T\n/**\n * ConnectorFuncOf\n * @description\n * Connect and invoke a function via connector.\n * It is used to connect a function to a name, and then invoke that function later.\n * @param T the type of the arguments\n * @param U the type of the return value\n */\nexport interface ConnectorFuncOf<T extends any[], U> {\n    /**\n     * Connect a function to the connector\n     * @description\n     * @param func The function to connect\n     */\n    connect(func: ConnectorFunc<T, U>): void;\n    /**\n     * Invoke the connected function\n     * @description If no function is connected yet, this will wait for the function to be connected and then invoke it.\n     * @param args The arguments to pass to the function\n     * @returns result of the function\n     */\n    invoke(...args: T): Promise<Awaited<U>>;\n    /**\n     * Invoke the connected function synchronously\n     * @description If no function is connected yet, this will throw an error.\n     * @param args The arguments to pass to the function\n     * @returns result of the function\n     */\n    invokeSync(...args: T): U;\n    /**\n     * Disconnect the connected function\n     * @description\n     * This will remove the function from the connector and clear the connection.\n     * @returns void\n     */\n    disconnect(): void;\n}\n/**\n * ConnectorInstanceOf\n * @description\n * Connect and get an instance via connector.\n * It is used to connect an instance to a name, and then retrieve that instance later.\n * @param T the type of the instance\n * @returns a promise that resolves to the instance\n */\nexport interface ConnectorInstanceOf<T> {\n    /**\n     * Connect an instance to the connector\n     * @description\n     * @param obj The instance to connect\n     */\n    connect(obj: T): void;\n    /**\n     * Get the connected instance\n     * @description\n     * @returns a promise that resolves to the connected instance\n     */\n    connected(): Promise<T>;\n    /**\n     * Disconnect the connected instance\n     * @description\n     * This will remove the instance from the connector and clear the connection.\n     * @returns void\n     */\n    disconnect(): void;\n}\n\nfunction getFuncOf<T extends any[], U>(name: string): ConnectorFuncOf<T, U> {\n\n    let connectedFunction: ConnectorFunc<T, U> | undefined;\n    let connectedFunctionTask = promiseWithResolver<ConnectorFunc<T, U>>();\n\n    const inst = {\n        connect: (func: ConnectorFunc<T, U>) => {\n            if (connectedFunction) {\n                inst.disconnect();\n            }\n            connectedFunctionTask.resolve(func);\n            connectedFunction = func;\n        },\n        invoke: async (...args: T): Promise<Awaited<U>> => {\n            if (connectedFunction) {\n                return await connectedFunction(...args);\n            }\n            const func = await connectedFunctionTask.promise;\n            return await func(...args);\n        },\n        invokeSync: (...args: T): U => {\n            if (!connectedFunction) {\n                throw new Error(`Function not connected: ${name}`);\n            }\n            return connectedFunction(...args);\n        },\n        disconnect: () => {\n            connectedFunction = undefined;\n            connectedFunctionTask = promiseWithResolver<ConnectorFunc<T, U>>();\n        }\n    }\n    return inst;\n}\n\nfunction getInstanceOf<T>(name: string): ConnectorInstanceOf<T> {\n    let connectedInstance = promiseWithResolver<ConnectorInstance<T>>();\n    let instance: T | undefined = undefined;\n    const inst = {\n        connect: (obj: T) => {\n            if (instance) {\n                inst.disconnect();\n            }\n            connectedInstance.resolve(obj);\n            instance = obj;\n        },\n        connected: async (): Promise<T> => {\n            if (instance) {\n                return instance;\n            }\n            return await connectedInstance.promise;\n        },\n        disconnect: () => {\n            instance = undefined;\n            connectedInstance = promiseWithResolver<ConnectorInstance<T>>();\n        }\n    };\n    return inst;\n}\n\nconst connectedFunctionsOf = new Map<string, ConnectorFuncOf<any, any>>();\nconst connectedInstancesOf = new Map<string, ConnectorInstanceOf<any>>();\n\n\n/**\n * Connector\n * @description\n * Connector is a utility class that allows you to connect functions and instances.\n * It provides a way to connect a function or an instance to a name, and then invoke that function or instance later.\n */\nexport const Connector = {\n    /**\n     * Get a function connector\n     * @description \n     * This method returns a function connector that allows you to connect a function to a name and then invoke that function later.\n     * @param name \n     * @returns <ConnectorFuncOf<T, U>>\n     */\n    funcOf<T extends any[], U>(name: string): ConnectorFuncOf<T, U> {\n        if (connectedFunctionsOf.has(name)) {\n            return connectedFunctionsOf.get(name) as ConnectorFuncOf<T, U>;\n        }\n        const func = getFuncOf<T, U>(name);\n        connectedFunctionsOf.set(name, func);\n        return func;\n    },\n\n    /**\n     * Connect a instance to the name\n     * @description\n     * This method returns a instance connector that allows you to connect a instance to a name and then retrieve that instance later.\n     * @param name \n     * @returns \n     */\n    instanceOf<T>(name: string): ConnectorInstanceOf<T> {\n        if (connectedInstancesOf.has(name)) {\n            return connectedInstancesOf.get(name) as ConnectorInstanceOf<T>;\n        }\n        const instance = getInstanceOf<T>(name);\n        connectedInstancesOf.set(name, instance);\n        return instance;\n    }\n}"],"names":[],"mappings":";;AAyFA,SAAS,SAAS,CAAqB,IAAY,EAAA;AAE/C,IAAA,IAAI,iBAAkD;AACtD,IAAA,IAAI,qBAAqB,GAAG,mBAAmB,EAAuB;AAEtE,IAAA,MAAM,IAAI,GAAG;AACT,QAAA,OAAO,EAAE,CAAC,IAAyB,KAAI;YACnC,IAAI,iBAAiB,EAAE;gBACnB,IAAI,CAAC,UAAU,EAAE;;AAErB,YAAA,qBAAqB,CAAC,OAAO,CAAC,IAAI,CAAC;YACnC,iBAAiB,GAAG,IAAI;SAC3B;AACD,QAAA,MAAM,EAAE,OAAO,GAAG,IAAO,KAAyB;YAC9C,IAAI,iBAAiB,EAAE;AACnB,gBAAA,OAAO,MAAM,iBAAiB,CAAC,GAAG,IAAI,CAAC;;AAE3C,YAAA,MAAM,IAAI,GAAG,MAAM,qBAAqB,CAAC,OAAO;AAChD,YAAA,OAAO,MAAM,IAAI,CAAC,GAAG,IAAI,CAAC;SAC7B;AACD,QAAA,UAAU,EAAE,CAAC,GAAG,IAAO,KAAO;YAC1B,IAAI,CAAC,iBAAiB,EAAE;AACpB,gBAAA,MAAM,IAAI,KAAK,CAAC,2BAA2B,IAAI,CAAA,CAAE,CAAC;;AAEtD,YAAA,OAAO,iBAAiB,CAAC,GAAG,IAAI,CAAC;SACpC;QACD,UAAU,EAAE,MAAK;YACb,iBAAiB,GAAG,SAAS;YAC7B,qBAAqB,GAAG,mBAAmB,EAAuB;;KAEzE;AACD,IAAA,OAAO,IAAI;AACf;AAEA,SAAS,aAAa,CAAI,IAAY,EAAA;AAClC,IAAA,IAAI,iBAAiB,GAAG,mBAAmB,EAAwB;IACnE,IAAI,QAAQ,GAAkB,SAAS;AACvC,IAAA,MAAM,IAAI,GAAG;AACT,QAAA,OAAO,EAAE,CAAC,GAAM,KAAI;YAChB,IAAI,QAAQ,EAAE;gBACV,IAAI,CAAC,UAAU,EAAE;;AAErB,YAAA,iBAAiB,CAAC,OAAO,CAAC,GAAG,CAAC;YAC9B,QAAQ,GAAG,GAAG;SACjB;QACD,SAAS,EAAE,YAAuB;YAC9B,IAAI,QAAQ,EAAE;AACV,gBAAA,OAAO,QAAQ;;AAEnB,YAAA,OAAO,MAAM,iBAAiB,CAAC,OAAO;SACzC;QACD,UAAU,EAAE,MAAK;YACb,QAAQ,GAAG,SAAS;YACpB,iBAAiB,GAAG,mBAAmB,EAAwB;;KAEtE;AACD,IAAA,OAAO,IAAI;AACf;AAEA,MAAM,oBAAoB,GAAG,IAAI,GAAG,EAAqC;AACzE,MAAM,oBAAoB,GAAG,IAAI,GAAG,EAAoC;AAGxE;;;;;AAKG;AACU,MAAA,SAAS,GAAG;AACrB;;;;;;AAMG;AACH,IAAA,MAAM,CAAqB,IAAY,EAAA;AACnC,QAAA,IAAI,oBAAoB,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;AAChC,YAAA,OAAO,oBAAoB,CAAC,GAAG,CAAC,IAAI,CAA0B;;AAElE,QAAA,MAAM,IAAI,GAAG,SAAS,CAAO,IAAI,CAAC;AAClC,QAAA,oBAAoB,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC;AACpC,QAAA,OAAO,IAAI;KACd;AAED;;;;;;AAMG;AACH,IAAA,UAAU,CAAI,IAAY,EAAA;AACtB,QAAA,IAAI,oBAAoB,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;AAChC,YAAA,OAAO,oBAAoB,CAAC,GAAG,CAAC,IAAI,CAA2B;;AAEnE,QAAA,MAAM,QAAQ,GAAG,aAAa,CAAQ,CAAC;AACvC,QAAA,oBAAoB,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC;AACxC,QAAA,OAAO,QAAQ;;;;;;"}