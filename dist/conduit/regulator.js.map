{"version":3,"file":"regulator.js","sources":["../../src/conduit/regulator.ts"],"sourcesContent":["/*\nRegulator \n*/\nimport { promiseWithResolver, PromiseWithResolvers } from \"../promises\";\n/**\n * Regulator \n * @description\n * Regulator allows you to regulate the number of concurrent processes.\n * \n * @example\n * const reg = new Regulator(2);\n * reg.onProcess(async example(args) => {\n *     // do something with args\n * });\n * \n * reg.invoke([1, 2, 3]); (all example will be called with [1, 2, 3] but only 2 at a time will be processed)\n */\nexport interface RegulatorOf<T extends any[], U> {\n    /**\n     * @description\n     * Set the maximum number of concurrent processes.\n     * Default is 1.\n     * @param n \n     * @returns <RegulatorOf<T, U>>\n     */\n    maxConcurrency(n: number): RegulatorOf<T, U>;\n    /**\n     * @description\n     * Set the function to be called when the regulator is invoked.\n     * @param func \n     * @returns <RegulatorOf<T, U>>\n     */\n    onProcess(func: (...args: T) => Promise<U>): RegulatorOf<T, U>;\n    /**\n     * @description\n     * Invoke the regulator with the given arguments.\n     * @param args \n     * @returns <Promise<U>>\n     */\n    invoke(...args: T): Promise<U>;\n    /**\n     * @description\n     * Invoke the regulator with the given arguments.\n     * This will call the function with the given arguments and return a promise that resolves when all functions are done.\n     * Note that order of the results is not same as the order of the arguments.\n     * @param items\n     */\n    invokeAll(items: T[]): Promise<U>[];\n}\n\n/**\n * @description\n * Create a regulator\n * @param _name \n * @returns return a regulator\n */\nfunction createRegulator<T extends any[], U>(_name: string): RegulatorOf<T, U> {\n    let maxConcurrency = 1;\n    let onProcess: (...args: T) => Promise<U> = () => { throw new Error(`not function connected on Regulator:${_name}`) };\n    const processing = new Set<Promise<U>>();\n    const scheduled = [] as [T, PromiseWithResolvers<U>][];\n    // let currentCount = 0;\n    let pumping = false;\n    const pump = async () => {\n        /* istanbul ignore if -- @preserve */\n        if (pumping) {\n            // Safety check to prevent multiple pumps\n            // Basically already checked during the startPumping\n            /* istanbul ignore  -- @preserve */\n            return;\n        }\n        try {\n            pumping = true;\n            do {\n                if (maxConcurrency <= 0) {\n                    return;\n                }\n                while (processing.size >= maxConcurrency) {\n                    if (maxConcurrency <= 0) {\n                        return;\n                    }\n                    // wait for any processing to finish\n                    await Promise.race(processing);\n                }\n                const [args, pw] = scheduled.shift()!;\n                const task = new Promise<U>((res, rej) => {\n                    try {\n                        res(onProcess(...args));\n                    } catch (e) {\n                        rej(e);\n                    }\n                });\n                processing.add(task);\n                task.then((result) => {\n                    processing.delete(task);\n                    pw.resolve(result);\n                }).catch((err) => {\n                    processing.delete(task);\n                    pw.reject(err);\n                });\n            } while (scheduled.length > 0);\n        } finally {\n            pumping = false;\n        }\n    }\n    const startPumping = () => {\n        if (pumping || scheduled.length === 0) {\n            return;\n        }\n        // fireAndForget(async () => await pump());\n        void pump();\n    };\n    const schedule = (arg: T) => {\n        const pw = promiseWithResolver<U>();\n        scheduled.push([arg, pw]);\n        startPumping();\n        return pw.promise;\n\n    }\n    const reg: RegulatorOf<T, U> = {\n        maxConcurrency: (n: number) => {\n            maxConcurrency = n;\n            startPumping();\n            return reg;\n        },\n        onProcess: (func: (...args: T) => Promise<U>) => {\n            onProcess = func;\n            startPumping();\n            return reg;\n        },\n        invoke: (...args: T) => {\n            const p = schedule(args);\n            return p;\n        },\n        invokeAll: (items: T[]) => {\n            return items.map(item => schedule(item));\n        }\n    }\n    return reg;\n}\nconst regulators = new Map<string, RegulatorOf<any, any>>();\n/**\n * @description\n * Get a regulator that allows you to regulate the number of concurrent processes.\n * @param name \n * @returns <RegulatorOf<T, U>>\n */\nexport const Regulator = {\n    /**\n     * Get a regulator\n     * @param name \n     * @returns <RegulatorOf<T, U>>\n     */\n    of: <T extends any[], U>(name: string): RegulatorOf<T, U> => {\n        if (!regulators.has(name)) {\n            regulators.set(name, createRegulator<T, U>(name));\n        }\n        return regulators.get(name)!;\n    }\n}"],"names":[],"mappings":"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"}