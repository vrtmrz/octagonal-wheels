{"version":3,"file":"actor.js","sources":["../src/actor.ts"],"sourcesContent":["const LogActorName = \"LogActor\";\r\nexport type ActorLogMessage = {\r\n    level?: \"info\" | \"warn\" | \"error\" | \"verbose\";\r\n    message: string;\r\n}\r\n\r\n/**\r\n * Represents a hub for managing actors.\r\n * @template T - The type of the message that can be dispatched to actors.\r\n */\r\nclass ActorHub<T> {\r\n    constructor() {\r\n        // super();\r\n    }\r\n\r\n    /**\r\n     * Represents a map of actors.\r\n     * The key is a name of actors, and the value is an array of actors of type T.\r\n     * Exposed for testing purposes. Do not use it directly.\r\n     */\r\n    _actorMap: Map<string, Actor<T>[]> = new Map();\r\n\r\n    /**\r\n     * Represents a map of round-robin indexes for actors.\r\n     * The key is a name of actors, and the value is an index of the actor in the array of actors of type T.\r\n     * Exposed for testing purposes. Do not use it directly.\r\n     */\r\n    _actorRRIndex: Map<string, number> = new Map();\r\n\r\n\r\n\r\n    /**\r\n     * Adds an actor to be managed by the hub.\r\n     * This method is used internally by the Actor class, but it can be used if you are sure and want to make an original and custom actor.\r\n     * @param actor - The actor to be added.\r\n     */\r\n    add(actor: Actor<T>) {\r\n        const name = actor.name;\r\n        const actors = this._actorMap.get(name) ?? [];\r\n        if (actor.multiInstance) {\r\n            actors.push(actor);\r\n        } else {\r\n            if (actors.length > 0) {\r\n                actors[0].destroy();\r\n                this.dispatch(LogActorName, { level: \"warn\", message: `The instance of Actor ${name} has been replaced` } as unknown as T);\r\n            }\r\n            actors.length = 0;\r\n            actors[0] = actor;\r\n        }\r\n        this._actorMap.set(name, actors);\r\n    }\r\n\r\n    remove(actor: Actor<T>) {\r\n        const name = actor.name;\r\n        const actors = this._actorMap.get(name) ?? [];\r\n        const index = actors.indexOf(actor);\r\n        if (index >= 0) {\r\n            actors.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    dispatch(actorName: string, message: T) {\r\n        const actors = this._actorMap.get(actorName) as Actor<T>[];\r\n        if (actors && actors.length > 0) {\r\n            let index = 0;\r\n            if (actors.length > 1) {\r\n                index = this._actorRRIndex.get(actorName) ?? 0;\r\n                index++;\r\n                index %= actors.length;\r\n                this._actorRRIndex.set(actorName, index);\r\n                // Round robin\r\n            }\r\n            actors[index]._enqueue(message);\r\n        } else {\r\n            console.warn(`${actorName} -${LogActorName}`);\r\n            if (actorName !== LogActorName) {\r\n                this.dispatch(LogActorName, { level: \"error\", message: `The instance of Actor ${actorName} is not assigned to the hub` } as unknown as T);\r\n            } else {\r\n                // Prevent infinite loop, but it should not happen. This will not be tested deeply.\r\n                console.error(`${LogActorName} is not assigned but dispatched to itself`);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Represents an abstract class for an actor.\r\n * @template T - The type of the message that the actor can process.\r\n */\r\nexport abstract class Actor<T> {\r\n    /**\r\n     * The name of the actor.\r\n     */\r\n    readonly name: string;\r\n    /**\r\n     * Indicates whether the actor is a multi-instance.\r\n     */\r\n    readonly multiInstance: boolean;\r\n\r\n    /**\r\n     * Represents the hub for actors.\r\n     */\r\n    static hub: ActorHub<any> = new ActorHub();\r\n\r\n    /**\r\n     * Initializes a new instance of the Actor class.\r\n     * @param name - The name of the actor. It will be the class name if not provided.\r\n     * @param multiInstance - Indicates whether the actor is a multi-instance. The default value is false. If true, the actor can have multiple instances to process each message concurrently.\r\n     */\r\n    constructor({ name, multiInstance }: { name?: string, multiInstance?: boolean } = {}) {\r\n        this.name = name || this.constructor.name;\r\n        this.multiInstance = multiInstance ?? false;\r\n        Actor.hub.add(this);\r\n    }\r\n\r\n\r\n\r\n    _busy: boolean = false;\r\n    async _process(message: T) {\r\n        // Internal method to pumping process a message\r\n        this._busy = true;\r\n        try {\r\n            const w = this.process(message);\r\n            if (w instanceof Promise) {\r\n                await w;\r\n            }\r\n        } finally {\r\n            this._busy = false;\r\n        }\r\n    }\r\n\r\n    // Promise chain to process messages sequentially. DO NOT USE IT. it is exposed for testing purposes.\r\n    __process: Promise<void> | undefined = Promise.resolve();\r\n\r\n    // Enqueue a message to be processed\r\n    _enqueue(message: T) {\r\n        if (this.__process === undefined) {\r\n            throw new Error(\"The actor has been destroyed\");\r\n        }\r\n        this.__process = this.__process.finally(() => {\r\n            return this._process(message);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Processes a message. This method should be overridden in the derived class. Automatically called when a message is dispatched to the actor.\r\n     * @param message - The message to be processed.\r\n     */\r\n    abstract process(message: T): Promise<void> | void;\r\n\r\n    /** \r\n     * Dispatches a message to the actor.\r\n     * Note: Even if we posted messages to the specific actor, the message will be processed by some actor instances if the actor is a multi-instance.\r\n     * @param message - The message to be dispatched.\r\n     */\r\n    post(message: T) {\r\n        Actor.hub.dispatch(this.name, message);\r\n    }\r\n\r\n\r\n    /**\r\n     * Posts a message to this actor instance.\r\n     * \r\n     * @param message - The message to be posted.\r\n     */\r\n    postToThisInstance(message: T) {\r\n        this._enqueue(message);\r\n    }\r\n\r\n    /**\r\n     * Dispatches a message to the specified actor.\r\n     * Utility method to dispatch a message to the actor, which is the subsequent actor of the current actor.\r\n     * Just for hiding the hub from the derived class.\r\n     * @template U - The type of the message.\r\n     * @template V - The type of the actor.\r\n     * @param actor - The actor to dispatch the message to.\r\n     * @param message - The message to be dispatched.\r\n     */\r\n    dispatch<U, V extends U>(actor: typeof Actor<V>, message: U) {\r\n        Actor.hub.dispatch(actor.name, message);\r\n    }\r\n\r\n\r\n    /**\r\n     * Destroys the actor instance.\r\n     */\r\n    destroy() {\r\n        if (this.__process) {\r\n            this.__process.finally(\r\n                () => this.__process = undefined as any\r\n            )\r\n            this.__process = undefined;\r\n        }\r\n        Actor.hub.remove(this);\r\n    }\r\n}\r\n\r\nexport abstract class LogActorBase extends Actor<ActorLogMessage> {\r\n    constructor() {\r\n        // Make it never overridable in the derived class\r\n        super({ name: `LogActor` });\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}